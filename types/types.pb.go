// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		Age
		Auth
		Player
		Players
		PlayerList
		PlayerName
		Address
		PlayerDetails
		Chunk
		Inventory
		InventorySlot
		Entity
		EntityId
		Item
		AbsolutePoint
		Point
		Actions
		Action
		Content
		EntityDefinition
		VoxelDefinition
		FormDefinition
		MaterialDefinition
		PrimitiveMap
		Primitive
		Nothing
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InventorySlot_ContainerType int32

const (
	InventorySlot_VOXEL  InventorySlot_ContainerType = 0
	InventorySlot_ENTITY InventorySlot_ContainerType = 1
	InventorySlot_ITEM   InventorySlot_ContainerType = 2
)

var InventorySlot_ContainerType_name = map[int32]string{
	0: "VOXEL",
	1: "ENTITY",
	2: "ITEM",
}
var InventorySlot_ContainerType_value = map[string]int32{
	"VOXEL":  0,
	"ENTITY": 1,
	"ITEM":   2,
}

func (x InventorySlot_ContainerType) String() string {
	return proto.EnumName(InventorySlot_ContainerType_name, int32(x))
}
func (InventorySlot_ContainerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{10, 0}
}

type Entity_Control int32

const (
	Entity_PLAYER Entity_Control = 0
	Entity_NPC    Entity_Control = 1
)

var Entity_Control_name = map[int32]string{
	0: "PLAYER",
	1: "NPC",
}
var Entity_Control_value = map[string]int32{
	"PLAYER": 0,
	"NPC":    1,
}

func (x Entity_Control) String() string {
	return proto.EnumName(Entity_Control_name, int32(x))
}
func (Entity_Control) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11, 0} }

type VoxelDefinition_State int32

const (
	VoxelDefinition_RigidSolid VoxelDefinition_State = 0
	VoxelDefinition_LooseSolid VoxelDefinition_State = 1
	VoxelDefinition_Liquid     VoxelDefinition_State = 2
	VoxelDefinition_Gas        VoxelDefinition_State = 3
)

var VoxelDefinition_State_name = map[int32]string{
	0: "RigidSolid",
	1: "LooseSolid",
	2: "Liquid",
	3: "Gas",
}
var VoxelDefinition_State_value = map[string]int32{
	"RigidSolid": 0,
	"LooseSolid": 1,
	"Liquid":     2,
	"Gas":        3,
}

func (x VoxelDefinition_State) String() string {
	return proto.EnumName(VoxelDefinition_State_name, int32(x))
}
func (VoxelDefinition_State) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{20, 0}
}

type FormDefinition_WearableSlot int32

const (
	FormDefinition_WearableHead   FormDefinition_WearableSlot = 0
	FormDefinition_WearableChest  FormDefinition_WearableSlot = 1
	FormDefinition_WearableHands  FormDefinition_WearableSlot = 2
	FormDefinition_WearableLegs   FormDefinition_WearableSlot = 3
	FormDefinition_WearableFeet   FormDefinition_WearableSlot = 4
	FormDefinition_WearableFinger FormDefinition_WearableSlot = 5
	FormDefinition_WearableNeck   FormDefinition_WearableSlot = 6
	FormDefinition_WearableEyes   FormDefinition_WearableSlot = 7
	FormDefinition_WearableWaist  FormDefinition_WearableSlot = 8
)

var FormDefinition_WearableSlot_name = map[int32]string{
	0: "WearableHead",
	1: "WearableChest",
	2: "WearableHands",
	3: "WearableLegs",
	4: "WearableFeet",
	5: "WearableFinger",
	6: "WearableNeck",
	7: "WearableEyes",
	8: "WearableWaist",
}
var FormDefinition_WearableSlot_value = map[string]int32{
	"WearableHead":   0,
	"WearableChest":  1,
	"WearableHands":  2,
	"WearableLegs":   3,
	"WearableFeet":   4,
	"WearableFinger": 5,
	"WearableNeck":   6,
	"WearableEyes":   7,
	"WearableWaist":  8,
}

func (x FormDefinition_WearableSlot) String() string {
	return proto.EnumName(FormDefinition_WearableSlot_name, int32(x))
}
func (FormDefinition_WearableSlot) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{21, 0}
}

type Age struct {
	Ticks uint64 `protobuf:"varint,1,opt,name=ticks,proto3" json:"ticks,omitempty"`
}

func (m *Age) Reset()                    { *m = Age{} }
func (m *Age) String() string            { return proto.CompactTextString(m) }
func (*Age) ProtoMessage()               {}
func (*Age) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Age) GetTicks() uint64 {
	if m != nil {
		return m.Ticks
	}
	return 0
}

type Auth struct {
	Name     string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Password []byte `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
}

func (m *Auth) Reset()                    { *m = Auth{} }
func (m *Auth) String() string            { return proto.CompactTextString(m) }
func (*Auth) ProtoMessage()               {}
func (*Auth) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *Auth) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Auth) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

type Player struct {
	EntityId int64          `protobuf:"varint,1,opt,name=entityId,proto3" json:"entityId,omitempty"`
	Name     string         `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	Password []byte         `protobuf:"bytes,3,opt,name=password,proto3" json:"password,omitempty"`
	LoggedIn bool           `protobuf:"varint,4,opt,name=loggedIn,proto3" json:"loggedIn,omitempty"`
	Spawn    *AbsolutePoint `protobuf:"bytes,5,opt,name=spawn" json:"spawn,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *Player) GetEntityId() int64 {
	if m != nil {
		return m.EntityId
	}
	return 0
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetPassword() []byte {
	if m != nil {
		return m.Password
	}
	return nil
}

func (m *Player) GetLoggedIn() bool {
	if m != nil {
		return m.LoggedIn
	}
	return false
}

func (m *Player) GetSpawn() *AbsolutePoint {
	if m != nil {
		return m.Spawn
	}
	return nil
}

type Players struct {
	Players map[string]*Player `protobuf:"bytes,1,rep,name=players" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Players) Reset()                    { *m = Players{} }
func (m *Players) String() string            { return proto.CompactTextString(m) }
func (*Players) ProtoMessage()               {}
func (*Players) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *Players) GetPlayers() map[string]*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

type PlayerList struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *PlayerList) Reset()                    { *m = PlayerList{} }
func (m *PlayerList) String() string            { return proto.CompactTextString(m) }
func (*PlayerList) ProtoMessage()               {}
func (*PlayerList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *PlayerList) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type PlayerName struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PlayerName) Reset()                    { *m = PlayerName{} }
func (m *PlayerName) String() string            { return proto.CompactTextString(m) }
func (*PlayerName) ProtoMessage()               {}
func (*PlayerName) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *PlayerName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Address struct {
	Addr string `protobuf:"bytes,1,opt,name=addr,proto3" json:"addr,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *Address) GetAddr() string {
	if m != nil {
		return m.Addr
	}
	return ""
}

type PlayerDetails struct {
	Player *Player `protobuf:"bytes,1,opt,name=player" json:"player,omitempty"`
	Entity *Entity `protobuf:"bytes,2,opt,name=entity" json:"entity,omitempty"`
}

func (m *PlayerDetails) Reset()                    { *m = PlayerDetails{} }
func (m *PlayerDetails) String() string            { return proto.CompactTextString(m) }
func (*PlayerDetails) ProtoMessage()               {}
func (*PlayerDetails) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *PlayerDetails) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *PlayerDetails) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

type Chunk struct {
	Voxels       []uint64                   `protobuf:"varint,1,rep,packed,name=voxels" json:"voxels,omitempty"`
	Compound     map[uint32]*Chunk_Compound `protobuf:"bytes,2,rep,name=compound" json:"compound,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Entities     []int64                    `protobuf:"varint,3,rep,packed,name=entities" json:"entities,omitempty"`
	Items        []*Chunk_ItemAtPoint       `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
	ActiveVoxels []*Point                   `protobuf:"bytes,5,rep,name=activeVoxels" json:"activeVoxels,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *Chunk) GetVoxels() []uint64 {
	if m != nil {
		return m.Voxels
	}
	return nil
}

func (m *Chunk) GetCompound() map[uint32]*Chunk_Compound {
	if m != nil {
		return m.Compound
	}
	return nil
}

func (m *Chunk) GetEntities() []int64 {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Chunk) GetItems() []*Chunk_ItemAtPoint {
	if m != nil {
		return m.Items
	}
	return nil
}

func (m *Chunk) GetActiveVoxels() []*Point {
	if m != nil {
		return m.ActiveVoxels
	}
	return nil
}

type Chunk_Compound struct {
	Inventory       *Inventory    `protobuf:"bytes,1,opt,name=inventory" json:"inventory,omitempty"`
	Properties      *PrimitiveMap `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	MultiblockChunk *Point        `protobuf:"bytes,3,opt,name=multiblockChunk" json:"multiblockChunk,omitempty"`
}

func (m *Chunk_Compound) Reset()                    { *m = Chunk_Compound{} }
func (m *Chunk_Compound) String() string            { return proto.CompactTextString(m) }
func (*Chunk_Compound) ProtoMessage()               {}
func (*Chunk_Compound) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8, 0} }

func (m *Chunk_Compound) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Chunk_Compound) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Chunk_Compound) GetMultiblockChunk() *Point {
	if m != nil {
		return m.MultiblockChunk
	}
	return nil
}

type Chunk_ItemAtPoint struct {
	Point *Point `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Item  *Item  `protobuf:"bytes,2,opt,name=item" json:"item,omitempty"`
}

func (m *Chunk_ItemAtPoint) Reset()                    { *m = Chunk_ItemAtPoint{} }
func (m *Chunk_ItemAtPoint) String() string            { return proto.CompactTextString(m) }
func (*Chunk_ItemAtPoint) ProtoMessage()               {}
func (*Chunk_ItemAtPoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8, 2} }

func (m *Chunk_ItemAtPoint) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *Chunk_ItemAtPoint) GetItem() *Item {
	if m != nil {
		return m.Item
	}
	return nil
}

type Inventory struct {
	Items []*Item `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *Inventory) Reset()                    { *m = Inventory{} }
func (m *Inventory) String() string            { return proto.CompactTextString(m) }
func (*Inventory) ProtoMessage()               {}
func (*Inventory) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

func (m *Inventory) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type InventorySlot struct {
	ContainerType InventorySlot_ContainerType `protobuf:"varint,1,opt,name=containerType,proto3,enum=InventorySlot_ContainerType" json:"containerType,omitempty"`
	// Types that are valid to be assigned to ContainerLocation:
	//	*InventorySlot_Point
	//	*InventorySlot_EntityId
	ContainerLocation isInventorySlot_ContainerLocation `protobuf_oneof:"containerLocation"`
	Slots             []uint32                          `protobuf:"varint,4,rep,packed,name=slots" json:"slots,omitempty"`
}

func (m *InventorySlot) Reset()                    { *m = InventorySlot{} }
func (m *InventorySlot) String() string            { return proto.CompactTextString(m) }
func (*InventorySlot) ProtoMessage()               {}
func (*InventorySlot) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

type isInventorySlot_ContainerLocation interface {
	isInventorySlot_ContainerLocation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InventorySlot_Point struct {
	Point *AbsolutePoint `protobuf:"bytes,2,opt,name=point,oneof"`
}
type InventorySlot_EntityId struct {
	EntityId int64 `protobuf:"varint,3,opt,name=entityId,proto3,oneof"`
}

func (*InventorySlot_Point) isInventorySlot_ContainerLocation()    {}
func (*InventorySlot_EntityId) isInventorySlot_ContainerLocation() {}

func (m *InventorySlot) GetContainerLocation() isInventorySlot_ContainerLocation {
	if m != nil {
		return m.ContainerLocation
	}
	return nil
}

func (m *InventorySlot) GetContainerType() InventorySlot_ContainerType {
	if m != nil {
		return m.ContainerType
	}
	return InventorySlot_VOXEL
}

func (m *InventorySlot) GetPoint() *AbsolutePoint {
	if x, ok := m.GetContainerLocation().(*InventorySlot_Point); ok {
		return x.Point
	}
	return nil
}

func (m *InventorySlot) GetEntityId() int64 {
	if x, ok := m.GetContainerLocation().(*InventorySlot_EntityId); ok {
		return x.EntityId
	}
	return 0
}

func (m *InventorySlot) GetSlots() []uint32 {
	if m != nil {
		return m.Slots
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InventorySlot) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InventorySlot_OneofMarshaler, _InventorySlot_OneofUnmarshaler, _InventorySlot_OneofSizer, []interface{}{
		(*InventorySlot_Point)(nil),
		(*InventorySlot_EntityId)(nil),
	}
}

func _InventorySlot_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InventorySlot)
	// containerLocation
	switch x := m.ContainerLocation.(type) {
	case *InventorySlot_Point:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Point); err != nil {
			return err
		}
	case *InventorySlot_EntityId:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.EntityId))
	case nil:
	default:
		return fmt.Errorf("InventorySlot.ContainerLocation has unexpected type %T", x)
	}
	return nil
}

func _InventorySlot_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InventorySlot)
	switch tag {
	case 2: // containerLocation.point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AbsolutePoint)
		err := b.DecodeMessage(msg)
		m.ContainerLocation = &InventorySlot_Point{msg}
		return true, err
	case 3: // containerLocation.entityId
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ContainerLocation = &InventorySlot_EntityId{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _InventorySlot_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InventorySlot)
	// containerLocation
	switch x := m.ContainerLocation.(type) {
	case *InventorySlot_Point:
		s := proto.Size(x.Point)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventorySlot_EntityId:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.EntityId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Entity struct {
	Id         int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       uint64         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Control    Entity_Control `protobuf:"varint,3,opt,name=control,proto3,enum=Entity_Control" json:"control,omitempty"`
	Location   *AbsolutePoint `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
	Properties *PrimitiveMap  `protobuf:"bytes,5,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory     `protobuf:"bytes,6,opt,name=inventory" json:"inventory,omitempty"`
	PlayerName string         `protobuf:"bytes,7,opt,name=playerName,proto3" json:"playerName,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *Entity) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Entity) GetType() uint64 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Entity) GetControl() Entity_Control {
	if m != nil {
		return m.Control
	}
	return Entity_PLAYER
}

func (m *Entity) GetLocation() *AbsolutePoint {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Entity) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Entity) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Entity) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

type EntityId struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *EntityId) Reset()                    { *m = EntityId{} }
func (m *EntityId) String() string            { return proto.CompactTextString(m) }
func (*EntityId) ProtoMessage()               {}
func (*EntityId) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *EntityId) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Item struct {
	Form uint32 `protobuf:"varint,1,opt,name=form,proto3" json:"form,omitempty"`
	// Types that are valid to be assigned to Substance:
	//	*Item_Material
	//	*Item_Components_
	Substance  isItem_Substance `protobuf_oneof:"substance"`
	Properties *PrimitiveMap    `protobuf:"bytes,4,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory       `protobuf:"bytes,5,opt,name=inventory" json:"inventory,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isItem_Substance interface {
	isItem_Substance()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Item_Material struct {
	Material uint32 `protobuf:"varint,2,opt,name=material,proto3,oneof"`
}
type Item_Components_ struct {
	Components *Item_Components `protobuf:"bytes,3,opt,name=components,oneof"`
}

func (*Item_Material) isItem_Substance()    {}
func (*Item_Components_) isItem_Substance() {}

func (m *Item) GetSubstance() isItem_Substance {
	if m != nil {
		return m.Substance
	}
	return nil
}

func (m *Item) GetForm() uint32 {
	if m != nil {
		return m.Form
	}
	return 0
}

func (m *Item) GetMaterial() uint32 {
	if x, ok := m.GetSubstance().(*Item_Material); ok {
		return x.Material
	}
	return 0
}

func (m *Item) GetComponents() *Item_Components {
	if x, ok := m.GetSubstance().(*Item_Components_); ok {
		return x.Components
	}
	return nil
}

func (m *Item) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Item) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Item) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Item_OneofMarshaler, _Item_OneofUnmarshaler, _Item_OneofSizer, []interface{}{
		(*Item_Material)(nil),
		(*Item_Components_)(nil),
	}
}

func _Item_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Material))
	case *Item_Components_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Components); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Item.Substance has unexpected type %T", x)
	}
	return nil
}

func _Item_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Item)
	switch tag {
	case 2: // substance.material
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Substance = &Item_Material{uint32(x)}
		return true, err
	case 3: // substance.components
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Item_Components)
		err := b.DecodeMessage(msg)
		m.Substance = &Item_Components_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Item_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Material))
	case *Item_Components_:
		s := proto.Size(x.Components)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Item_Components struct {
	Components []*Item `protobuf:"bytes,1,rep,name=components" json:"components,omitempty"`
}

func (m *Item_Components) Reset()                    { *m = Item_Components{} }
func (m *Item_Components) String() string            { return proto.CompactTextString(m) }
func (*Item_Components) ProtoMessage()               {}
func (*Item_Components) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13, 0} }

func (m *Item_Components) GetComponents() []*Item {
	if m != nil {
		return m.Components
	}
	return nil
}

type AbsolutePoint struct {
	Chunk *Point `protobuf:"bytes,1,opt,name=chunk" json:"chunk,omitempty"`
	Voxel *Point `protobuf:"bytes,2,opt,name=voxel" json:"voxel,omitempty"`
}

func (m *AbsolutePoint) Reset()                    { *m = AbsolutePoint{} }
func (m *AbsolutePoint) String() string            { return proto.CompactTextString(m) }
func (*AbsolutePoint) ProtoMessage()               {}
func (*AbsolutePoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *AbsolutePoint) GetChunk() *Point {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *AbsolutePoint) GetVoxel() *Point {
	if m != nil {
		return m.Voxel
	}
	return nil
}

type Point struct {
	X int64 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y int64 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	Z int64 `protobuf:"varint,3,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *Point) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Point) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type Actions struct {
	Actions []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
}

func (m *Actions) Reset()                    { *m = Actions{} }
func (m *Actions) String() string            { return proto.CompactTextString(m) }
func (*Actions) ProtoMessage()               {}
func (*Actions) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func (m *Actions) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type Action struct {
	PlayerName string `protobuf:"bytes,1,opt,name=playerName,proto3" json:"playerName,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*Action_Move
	//	*Action_Craft
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Move struct {
	Move *Action_MoveAction `protobuf:"bytes,2,opt,name=move,oneof"`
}
type Action_Craft struct {
	Craft *Action_CraftAction `protobuf:"bytes,3,opt,name=craft,oneof"`
}

func (*Action_Move) isAction_Action()  {}
func (*Action_Craft) isAction_Action() {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

func (m *Action) GetMove() *Action_MoveAction {
	if x, ok := m.GetAction().(*Action_Move); ok {
		return x.Move
	}
	return nil
}

func (m *Action) GetCraft() *Action_CraftAction {
	if x, ok := m.GetAction().(*Action_Craft); ok {
		return x.Craft
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Action) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Action_OneofMarshaler, _Action_OneofUnmarshaler, _Action_OneofSizer, []interface{}{
		(*Action_Move)(nil),
		(*Action_Craft)(nil),
	}
}

func _Action_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Move); err != nil {
			return err
		}
	case *Action_Craft:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Craft); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Action.Action has unexpected type %T", x)
	}
	return nil
}

func _Action_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Action)
	switch tag {
	case 2: // action.move
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_MoveAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Move{msg}
		return true, err
	case 3: // action.craft
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_CraftAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Craft{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Action_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		s := proto.Size(x.Move)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Action_Craft:
		s := proto.Size(x.Craft)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Action_MoveAction struct {
	WhereTo *AbsolutePoint `protobuf:"bytes,1,opt,name=whereTo" json:"whereTo,omitempty"`
}

func (m *Action_MoveAction) Reset()                    { *m = Action_MoveAction{} }
func (m *Action_MoveAction) String() string            { return proto.CompactTextString(m) }
func (*Action_MoveAction) ProtoMessage()               {}
func (*Action_MoveAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17, 0} }

func (m *Action_MoveAction) GetWhereTo() *AbsolutePoint {
	if m != nil {
		return m.WhereTo
	}
	return nil
}

type Action_CraftAction struct {
	Verb           uint32           `protobuf:"varint,1,opt,name=verb,proto3" json:"verb,omitempty"`
	ObjectLocation *AbsolutePoint   `protobuf:"bytes,2,opt,name=objectLocation" json:"objectLocation,omitempty"`
	Inputs         []*InventorySlot `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
	OutputForms    []uint32         `protobuf:"varint,4,rep,packed,name=outputForms" json:"outputForms,omitempty"`
}

func (m *Action_CraftAction) Reset()                    { *m = Action_CraftAction{} }
func (m *Action_CraftAction) String() string            { return proto.CompactTextString(m) }
func (*Action_CraftAction) ProtoMessage()               {}
func (*Action_CraftAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17, 1} }

func (m *Action_CraftAction) GetVerb() uint32 {
	if m != nil {
		return m.Verb
	}
	return 0
}

func (m *Action_CraftAction) GetObjectLocation() *AbsolutePoint {
	if m != nil {
		return m.ObjectLocation
	}
	return nil
}

func (m *Action_CraftAction) GetInputs() []*InventorySlot {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Action_CraftAction) GetOutputForms() []uint32 {
	if m != nil {
		return m.OutputForms
	}
	return nil
}

type Content struct {
	E map[uint64]*EntityDefinition `protobuf:"bytes,1,rep,name=e" json:"e,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// only 2^16 voxel types are supported
	V map[uint64]*VoxelDefinition    `protobuf:"bytes,2,rep,name=v" json:"v,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	F map[uint64]*FormDefinition     `protobuf:"bytes,3,rep,name=f" json:"f,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	M map[uint64]*MaterialDefinition `protobuf:"bytes,4,rep,name=m" json:"m,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Content) Reset()                    { *m = Content{} }
func (m *Content) String() string            { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()               {}
func (*Content) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *Content) GetE() map[uint64]*EntityDefinition {
	if m != nil {
		return m.E
	}
	return nil
}

func (m *Content) GetV() map[uint64]*VoxelDefinition {
	if m != nil {
		return m.V
	}
	return nil
}

func (m *Content) GetF() map[uint64]*FormDefinition {
	if m != nil {
		return m.F
	}
	return nil
}

func (m *Content) GetM() map[uint64]*MaterialDefinition {
	if m != nil {
		return m.M
	}
	return nil
}

type EntityDefinition struct {
	Name              string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Falls             bool   `protobuf:"varint,2,opt,name=falls,proto3" json:"falls,omitempty"`
	InventoryCapacity uint64 `protobuf:"varint,3,opt,name=inventoryCapacity,proto3" json:"inventoryCapacity,omitempty"`
}

func (m *EntityDefinition) Reset()                    { *m = EntityDefinition{} }
func (m *EntityDefinition) String() string            { return proto.CompactTextString(m) }
func (*EntityDefinition) ProtoMessage()               {}
func (*EntityDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *EntityDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *EntityDefinition) GetFalls() bool {
	if m != nil {
		return m.Falls
	}
	return false
}

func (m *EntityDefinition) GetInventoryCapacity() uint64 {
	if m != nil {
		return m.InventoryCapacity
	}
	return 0
}

type VoxelDefinition struct {
	Name  string                `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	State VoxelDefinition_State `protobuf:"varint,2,opt,name=state,proto3,enum=VoxelDefinition_State" json:"state,omitempty"`
}

func (m *VoxelDefinition) Reset()                    { *m = VoxelDefinition{} }
func (m *VoxelDefinition) String() string            { return proto.CompactTextString(m) }
func (*VoxelDefinition) ProtoMessage()               {}
func (*VoxelDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

func (m *VoxelDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *VoxelDefinition) GetState() VoxelDefinition_State {
	if m != nil {
		return m.State
	}
	return VoxelDefinition_RigidSolid
}

type FormDefinition struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// How it's used
	Wieldable1Handed bool                        `protobuf:"varint,100,opt,name=Wieldable1Handed,proto3" json:"Wieldable1Handed,omitempty"`
	Wieldable2Handed bool                        `protobuf:"varint,101,opt,name=Wieldable2Handed,proto3" json:"Wieldable2Handed,omitempty"`
	WearableSlot     FormDefinition_WearableSlot `protobuf:"varint,200,opt,name=wearableSlot,proto3,enum=FormDefinition_WearableSlot" json:"wearableSlot,omitempty"`
	// Tool or Weapon
	//   values are percentages
	Sharpness uint32 `protobuf:"varint,300,opt,name=Sharpness,proto3" json:"Sharpness,omitempty"`
	Heft      uint32 `protobuf:"varint,301,opt,name=Heft,proto3" json:"Heft,omitempty"`
	Digging   uint32 `protobuf:"varint,302,opt,name=Digging,proto3" json:"Digging,omitempty"`
	Mining    uint32 `protobuf:"varint,303,opt,name=Mining,proto3" json:"Mining,omitempty"`
	// Clothing or Armor
	//   values are percentages
	PiercingProtection uint32 `protobuf:"varint,400,opt,name=PiercingProtection,proto3" json:"PiercingProtection,omitempty"`
	BluntProtection    uint32 `protobuf:"varint,401,opt,name=BluntProtection,proto3" json:"BluntProtection,omitempty"`
	Insulation         uint32 `protobuf:"varint,402,opt,name=Insulation,proto3" json:"Insulation,omitempty"`
	// Both
	//   values are percentages
	Strength uint32 `protobuf:"varint,500,opt,name=Strength,proto3" json:"Strength,omitempty"`
}

func (m *FormDefinition) Reset()                    { *m = FormDefinition{} }
func (m *FormDefinition) String() string            { return proto.CompactTextString(m) }
func (*FormDefinition) ProtoMessage()               {}
func (*FormDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

func (m *FormDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *FormDefinition) GetWieldable1Handed() bool {
	if m != nil {
		return m.Wieldable1Handed
	}
	return false
}

func (m *FormDefinition) GetWieldable2Handed() bool {
	if m != nil {
		return m.Wieldable2Handed
	}
	return false
}

func (m *FormDefinition) GetWearableSlot() FormDefinition_WearableSlot {
	if m != nil {
		return m.WearableSlot
	}
	return FormDefinition_WearableHead
}

func (m *FormDefinition) GetSharpness() uint32 {
	if m != nil {
		return m.Sharpness
	}
	return 0
}

func (m *FormDefinition) GetHeft() uint32 {
	if m != nil {
		return m.Heft
	}
	return 0
}

func (m *FormDefinition) GetDigging() uint32 {
	if m != nil {
		return m.Digging
	}
	return 0
}

func (m *FormDefinition) GetMining() uint32 {
	if m != nil {
		return m.Mining
	}
	return 0
}

func (m *FormDefinition) GetPiercingProtection() uint32 {
	if m != nil {
		return m.PiercingProtection
	}
	return 0
}

func (m *FormDefinition) GetBluntProtection() uint32 {
	if m != nil {
		return m.BluntProtection
	}
	return 0
}

func (m *FormDefinition) GetInsulation() uint32 {
	if m != nil {
		return m.Insulation
	}
	return 0
}

func (m *FormDefinition) GetStrength() uint32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

type MaterialDefinition struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// Classifications
	Metallic bool `protobuf:"varint,2,opt,name=Metallic,proto3" json:"Metallic,omitempty"`
	Wooden   bool `protobuf:"varint,3,opt,name=Wooden,proto3" json:"Wooden,omitempty"`
	Fleshy   bool `protobuf:"varint,4,opt,name=Fleshy,proto3" json:"Fleshy,omitempty"`
	Salty    bool `protobuf:"varint,5,opt,name=Salty,proto3" json:"Salty,omitempty"`
	// Physical Properties
	PH      uint32 `protobuf:"varint,100,opt,name=PH,proto3" json:"PH,omitempty"`
	SolidAt uint32 `protobuf:"varint,101,opt,name=SolidAt,proto3" json:"SolidAt,omitempty"`
	GasAt   uint32 `protobuf:"varint,102,opt,name=GasAt,proto3" json:"GasAt,omitempty"`
	// Item Properties
	//   values are percentages
	Sharpness uint32 `protobuf:"varint,200,opt,name=Sharpness,proto3" json:"Sharpness,omitempty"`
	Heft      uint32 `protobuf:"varint,201,opt,name=Heft,proto3" json:"Heft,omitempty"`
	Strength  uint32 `protobuf:"varint,202,opt,name=Strength,proto3" json:"Strength,omitempty"`
}

func (m *MaterialDefinition) Reset()                    { *m = MaterialDefinition{} }
func (m *MaterialDefinition) String() string            { return proto.CompactTextString(m) }
func (*MaterialDefinition) ProtoMessage()               {}
func (*MaterialDefinition) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{22} }

func (m *MaterialDefinition) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *MaterialDefinition) GetMetallic() bool {
	if m != nil {
		return m.Metallic
	}
	return false
}

func (m *MaterialDefinition) GetWooden() bool {
	if m != nil {
		return m.Wooden
	}
	return false
}

func (m *MaterialDefinition) GetFleshy() bool {
	if m != nil {
		return m.Fleshy
	}
	return false
}

func (m *MaterialDefinition) GetSalty() bool {
	if m != nil {
		return m.Salty
	}
	return false
}

func (m *MaterialDefinition) GetPH() uint32 {
	if m != nil {
		return m.PH
	}
	return 0
}

func (m *MaterialDefinition) GetSolidAt() uint32 {
	if m != nil {
		return m.SolidAt
	}
	return 0
}

func (m *MaterialDefinition) GetGasAt() uint32 {
	if m != nil {
		return m.GasAt
	}
	return 0
}

func (m *MaterialDefinition) GetSharpness() uint32 {
	if m != nil {
		return m.Sharpness
	}
	return 0
}

func (m *MaterialDefinition) GetHeft() uint32 {
	if m != nil {
		return m.Heft
	}
	return 0
}

func (m *MaterialDefinition) GetStrength() uint32 {
	if m != nil {
		return m.Strength
	}
	return 0
}

type PrimitiveMap struct {
	Map map[string]*Primitive `protobuf:"bytes,1,rep,name=map" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PrimitiveMap) Reset()                    { *m = PrimitiveMap{} }
func (m *PrimitiveMap) String() string            { return proto.CompactTextString(m) }
func (*PrimitiveMap) ProtoMessage()               {}
func (*PrimitiveMap) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{23} }

func (m *PrimitiveMap) GetMap() map[string]*Primitive {
	if m != nil {
		return m.Map
	}
	return nil
}

type Primitive struct {
	// Types that are valid to be assigned to Value:
	//	*Primitive_String_
	//	*Primitive_Int
	//	*Primitive_Bool
	//	*Primitive_Float
	Value isPrimitive_Value `protobuf_oneof:"value"`
}

func (m *Primitive) Reset()                    { *m = Primitive{} }
func (m *Primitive) String() string            { return proto.CompactTextString(m) }
func (*Primitive) ProtoMessage()               {}
func (*Primitive) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{24} }

type isPrimitive_Value interface {
	isPrimitive_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Primitive_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,proto3,oneof"`
}
type Primitive_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,proto3,oneof"`
}
type Primitive_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,proto3,oneof"`
}
type Primitive_Float struct {
	Float float32 `protobuf:"fixed32,4,opt,name=float,proto3,oneof"`
}

func (*Primitive_String_) isPrimitive_Value() {}
func (*Primitive_Int) isPrimitive_Value()     {}
func (*Primitive_Bool) isPrimitive_Value()    {}
func (*Primitive_Float) isPrimitive_Value()   {}

func (m *Primitive) GetValue() isPrimitive_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Primitive) GetString_() string {
	if x, ok := m.GetValue().(*Primitive_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Primitive) GetInt() int64 {
	if x, ok := m.GetValue().(*Primitive_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Primitive) GetBool() bool {
	if x, ok := m.GetValue().(*Primitive_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Primitive) GetFloat() float32 {
	if x, ok := m.GetValue().(*Primitive_Float); ok {
		return x.Float
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Primitive) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Primitive_OneofMarshaler, _Primitive_OneofUnmarshaler, _Primitive_OneofSizer, []interface{}{
		(*Primitive_String_)(nil),
		(*Primitive_Int)(nil),
		(*Primitive_Bool)(nil),
		(*Primitive_Float)(nil),
	}
}

func _Primitive_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *Primitive_Int:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *Primitive_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Primitive_Float:
		_ = b.EncodeVarint(4<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float)))
	case nil:
	default:
		return fmt.Errorf("Primitive.Value has unexpected type %T", x)
	}
	return nil
}

func _Primitive_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Primitive)
	switch tag {
	case 1: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Primitive_String_{x}
		return true, err
	case 2: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Int{int64(x)}
		return true, err
	case 3: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Bool{x != 0}
		return true, err
	case 4: // value.float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &Primitive_Float{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _Primitive_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Primitive_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Primitive_Bool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *Primitive_Float:
		n += proto.SizeVarint(4<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Nothing struct {
}

func (m *Nothing) Reset()                    { *m = Nothing{} }
func (m *Nothing) String() string            { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()               {}
func (*Nothing) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{25} }

func init() {
	proto.RegisterType((*Age)(nil), "Age")
	proto.RegisterType((*Auth)(nil), "Auth")
	proto.RegisterType((*Player)(nil), "Player")
	proto.RegisterType((*Players)(nil), "Players")
	proto.RegisterType((*PlayerList)(nil), "PlayerList")
	proto.RegisterType((*PlayerName)(nil), "PlayerName")
	proto.RegisterType((*Address)(nil), "Address")
	proto.RegisterType((*PlayerDetails)(nil), "PlayerDetails")
	proto.RegisterType((*Chunk)(nil), "Chunk")
	proto.RegisterType((*Chunk_Compound)(nil), "Chunk.Compound")
	proto.RegisterType((*Chunk_ItemAtPoint)(nil), "Chunk.ItemAtPoint")
	proto.RegisterType((*Inventory)(nil), "Inventory")
	proto.RegisterType((*InventorySlot)(nil), "InventorySlot")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*EntityId)(nil), "EntityId")
	proto.RegisterType((*Item)(nil), "Item")
	proto.RegisterType((*Item_Components)(nil), "Item.Components")
	proto.RegisterType((*AbsolutePoint)(nil), "AbsolutePoint")
	proto.RegisterType((*Point)(nil), "Point")
	proto.RegisterType((*Actions)(nil), "Actions")
	proto.RegisterType((*Action)(nil), "Action")
	proto.RegisterType((*Action_MoveAction)(nil), "Action.MoveAction")
	proto.RegisterType((*Action_CraftAction)(nil), "Action.CraftAction")
	proto.RegisterType((*Content)(nil), "Content")
	proto.RegisterType((*EntityDefinition)(nil), "EntityDefinition")
	proto.RegisterType((*VoxelDefinition)(nil), "VoxelDefinition")
	proto.RegisterType((*FormDefinition)(nil), "FormDefinition")
	proto.RegisterType((*MaterialDefinition)(nil), "MaterialDefinition")
	proto.RegisterType((*PrimitiveMap)(nil), "PrimitiveMap")
	proto.RegisterType((*Primitive)(nil), "Primitive")
	proto.RegisterType((*Nothing)(nil), "Nothing")
	proto.RegisterEnum("InventorySlot_ContainerType", InventorySlot_ContainerType_name, InventorySlot_ContainerType_value)
	proto.RegisterEnum("Entity_Control", Entity_Control_name, Entity_Control_value)
	proto.RegisterEnum("VoxelDefinition_State", VoxelDefinition_State_name, VoxelDefinition_State_value)
	proto.RegisterEnum("FormDefinition_WearableSlot", FormDefinition_WearableSlot_name, FormDefinition_WearableSlot_value)
}
func (m *Age) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Age) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ticks != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ticks))
	}
	return i, nil
}

func (m *Auth) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Auth) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.EntityId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.EntityId))
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if m.LoggedIn {
		dAtA[i] = 0x20
		i++
		if m.LoggedIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Spawn != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Spawn.Size()))
		n1, err := m.Spawn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Players) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Players) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, _ := range m.Players {
			dAtA[i] = 0xa
			i++
			v := m.Players[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *PlayerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PlayerName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Address) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Address) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addr) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Addr)))
		i += copy(dAtA[i:], m.Addr)
	}
	return i, nil
}

func (m *PlayerDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Player.Size()))
		n3, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Entity != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Entity.Size()))
		n4, err := m.Entity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		dAtA6 := make([]byte, len(m.Voxels)*10)
		var j5 int
		for _, num := range m.Voxels {
			for num >= 1<<7 {
				dAtA6[j5] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j5++
			}
			dAtA6[j5] = uint8(num)
			j5++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j5))
		i += copy(dAtA[i:], dAtA6[:j5])
	}
	if len(m.Compound) > 0 {
		for k, _ := range m.Compound {
			dAtA[i] = 0x12
			i++
			v := m.Compound[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n7, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n7
			}
		}
	}
	if len(m.Entities) > 0 {
		dAtA9 := make([]byte, len(m.Entities)*10)
		var j8 int
		for _, num1 := range m.Entities {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA9[j8] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j8++
			}
			dAtA9[j8] = uint8(num)
			j8++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j8))
		i += copy(dAtA[i:], dAtA9[:j8])
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ActiveVoxels) > 0 {
		for _, msg := range m.ActiveVoxels {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chunk_Compound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_Compound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Inventory != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n10, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	if m.Properties != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n11, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.MultiblockChunk != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MultiblockChunk.Size()))
		n12, err := m.MultiblockChunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Chunk_ItemAtPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_ItemAtPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Point != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n13, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.Item != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n14, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	return i, nil
}

func (m *Inventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inventory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InventorySlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventorySlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		nn15, err := m.ContainerLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn15
	}
	if len(m.Slots) > 0 {
		dAtA17 := make([]byte, len(m.Slots)*10)
		var j16 int
		for _, num := range m.Slots {
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j16))
		i += copy(dAtA[i:], dAtA17[:j16])
	}
	return i, nil
}

func (m *InventorySlot_Point) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n18, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}
func (m *InventorySlot_EntityId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.EntityId))
	return i, nil
}
func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Control != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Control))
	}
	if m.Location != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Location.Size()))
		n19, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	if m.Properties != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n20, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Inventory != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n21, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	return i, nil
}

func (m *EntityId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Form != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Form))
	}
	if m.Substance != nil {
		nn22, err := m.Substance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn22
	}
	if m.Properties != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n23, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Inventory != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n24, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}

func (m *Item_Material) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Material))
	return i, nil
}
func (m *Item_Components_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Components != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Components.Size()))
		n25, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}
func (m *Item_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, msg := range m.Components {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AbsolutePoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbsolutePoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Chunk.Size()))
		n26, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.Voxel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Voxel.Size()))
		n27, err := m.Voxel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	return i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Y))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Z))
	}
	return i, nil
}

func (m *Actions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	if m.Action != nil {
		nn28, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn28
	}
	return i, nil
}

func (m *Action_Move) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Move != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Move.Size()))
		n29, err := m.Move.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *Action_Craft) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Craft != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Craft.Size()))
		n30, err := m.Craft.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *Action_MoveAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_MoveAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WhereTo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WhereTo.Size()))
		n31, err := m.WhereTo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}

func (m *Action_CraftAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_CraftAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Verb != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectLocation.Size()))
		n32, err := m.ObjectLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputForms) > 0 {
		dAtA34 := make([]byte, len(m.OutputForms)*10)
		var j33 int
		for _, num := range m.OutputForms {
			for num >= 1<<7 {
				dAtA34[j33] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j33++
			}
			dAtA34[j33] = uint8(num)
			j33++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j33))
		i += copy(dAtA[i:], dAtA34[:j33])
	}
	return i, nil
}

func (m *Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Content) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.E) > 0 {
		for k, _ := range m.E {
			dAtA[i] = 0xa
			i++
			v := m.E[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n35, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n35
			}
		}
	}
	if len(m.V) > 0 {
		for k, _ := range m.V {
			dAtA[i] = 0x12
			i++
			v := m.V[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n36, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n36
			}
		}
	}
	if len(m.F) > 0 {
		for k, _ := range m.F {
			dAtA[i] = 0x1a
			i++
			v := m.F[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n37, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n37
			}
		}
	}
	if len(m.M) > 0 {
		for k, _ := range m.M {
			dAtA[i] = 0x22
			i++
			v := m.M[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n38, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n38
			}
		}
	}
	return i, nil
}

func (m *EntityDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Falls {
		dAtA[i] = 0x10
		i++
		if m.Falls {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.InventoryCapacity != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.InventoryCapacity))
	}
	return i, nil
}

func (m *VoxelDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoxelDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.State != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.State))
	}
	return i, nil
}

func (m *FormDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FormDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Wieldable1Handed {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		if m.Wieldable1Handed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Wieldable2Handed {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		if m.Wieldable2Handed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.WearableSlot != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WearableSlot))
	}
	if m.Sharpness != 0 {
		dAtA[i] = 0xe0
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Sharpness))
	}
	if m.Heft != 0 {
		dAtA[i] = 0xe8
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Heft))
	}
	if m.Digging != 0 {
		dAtA[i] = 0xf0
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Digging))
	}
	if m.Mining != 0 {
		dAtA[i] = 0xf8
		i++
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Mining))
	}
	if m.PiercingProtection != 0 {
		dAtA[i] = 0x80
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PiercingProtection))
	}
	if m.BluntProtection != 0 {
		dAtA[i] = 0x88
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.BluntProtection))
	}
	if m.Insulation != 0 {
		dAtA[i] = 0x90
		i++
		dAtA[i] = 0x19
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Insulation))
	}
	if m.Strength != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x1f
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Strength))
	}
	return i, nil
}

func (m *MaterialDefinition) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MaterialDefinition) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.Metallic {
		dAtA[i] = 0x10
		i++
		if m.Metallic {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Wooden {
		dAtA[i] = 0x18
		i++
		if m.Wooden {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Fleshy {
		dAtA[i] = 0x20
		i++
		if m.Fleshy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Salty {
		dAtA[i] = 0x28
		i++
		if m.Salty {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.PH != 0 {
		dAtA[i] = 0xa0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.PH))
	}
	if m.SolidAt != 0 {
		dAtA[i] = 0xa8
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.SolidAt))
	}
	if m.GasAt != 0 {
		dAtA[i] = 0xb0
		i++
		dAtA[i] = 0x6
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.GasAt))
	}
	if m.Sharpness != 0 {
		dAtA[i] = 0xc0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Sharpness))
	}
	if m.Heft != 0 {
		dAtA[i] = 0xc8
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Heft))
	}
	if m.Strength != 0 {
		dAtA[i] = 0xd0
		i++
		dAtA[i] = 0xc
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Strength))
	}
	return i, nil
}

func (m *PrimitiveMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, _ := range m.Map {
			dAtA[i] = 0xa
			i++
			v := m.Map[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n39, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n39
			}
		}
	}
	return i, nil
}

func (m *Primitive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primitive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn40, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn40
	}
	return i, nil
}

func (m *Primitive_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.String_)))
	i += copy(dAtA[i:], m.String_)
	return i, nil
}
func (m *Primitive_Int) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Int))
	return i, nil
}
func (m *Primitive_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Primitive_Float) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x25
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
	i += 4
	return i, nil
}
func (m *Nothing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nothing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Age) Size() (n int) {
	var l int
	_ = l
	if m.Ticks != 0 {
		n += 1 + sovTypes(uint64(m.Ticks))
	}
	return n
}

func (m *Auth) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Player) Size() (n int) {
	var l int
	_ = l
	if m.EntityId != 0 {
		n += 1 + sovTypes(uint64(m.EntityId))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LoggedIn {
		n += 2
	}
	if m.Spawn != nil {
		l = m.Spawn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Players) Size() (n int) {
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlayerList) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PlayerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Address) Size() (n int) {
	var l int
	_ = l
	l = len(m.Addr)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PlayerDetails) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		l = 0
		for _, e := range m.Voxels {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Compound) > 0 {
		for k, v := range m.Compound {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Entities) > 0 {
		l = 0
		for _, e := range m.Entities {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.ActiveVoxels) > 0 {
		for _, e := range m.ActiveVoxels {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Chunk_Compound) Size() (n int) {
	var l int
	_ = l
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MultiblockChunk != nil {
		l = m.MultiblockChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk_ItemAtPoint) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Inventory) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *InventorySlot) Size() (n int) {
	var l int
	_ = l
	if m.ContainerType != 0 {
		n += 1 + sovTypes(uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		n += m.ContainerLocation.Size()
	}
	if len(m.Slots) > 0 {
		l = 0
		for _, e := range m.Slots {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *InventorySlot_Point) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InventorySlot_EntityId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.EntityId))
	return n
}
func (m *Entity) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Control != 0 {
		n += 1 + sovTypes(uint64(m.Control))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EntityId) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.Form != 0 {
		n += 1 + sovTypes(uint64(m.Form))
	}
	if m.Substance != nil {
		n += m.Substance.Size()
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Item_Material) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Material))
	return n
}
func (m *Item_Components_) Size() (n int) {
	var l int
	_ = l
	if m.Components != nil {
		l = m.Components.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Item_Components) Size() (n int) {
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AbsolutePoint) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Voxel != nil {
		l = m.Voxel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovTypes(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sovTypes(uint64(m.Z))
	}
	return n
}

func (m *Actions) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Action) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Move) Size() (n int) {
	var l int
	_ = l
	if m.Move != nil {
		l = m.Move.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_Craft) Size() (n int) {
	var l int
	_ = l
	if m.Craft != nil {
		l = m.Craft.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_MoveAction) Size() (n int) {
	var l int
	_ = l
	if m.WhereTo != nil {
		l = m.WhereTo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Action_CraftAction) Size() (n int) {
	var l int
	_ = l
	if m.Verb != 0 {
		n += 1 + sovTypes(uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		l = m.ObjectLocation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.OutputForms) > 0 {
		l = 0
		for _, e := range m.OutputForms {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *Content) Size() (n int) {
	var l int
	_ = l
	if len(m.E) > 0 {
		for k, v := range m.E {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.V) > 0 {
		for k, v := range m.V {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.F) > 0 {
		for k, v := range m.F {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.M) > 0 {
		for k, v := range m.M {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EntityDefinition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Falls {
		n += 2
	}
	if m.InventoryCapacity != 0 {
		n += 1 + sovTypes(uint64(m.InventoryCapacity))
	}
	return n
}

func (m *VoxelDefinition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.State != 0 {
		n += 1 + sovTypes(uint64(m.State))
	}
	return n
}

func (m *FormDefinition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Wieldable1Handed {
		n += 3
	}
	if m.Wieldable2Handed {
		n += 3
	}
	if m.WearableSlot != 0 {
		n += 2 + sovTypes(uint64(m.WearableSlot))
	}
	if m.Sharpness != 0 {
		n += 2 + sovTypes(uint64(m.Sharpness))
	}
	if m.Heft != 0 {
		n += 2 + sovTypes(uint64(m.Heft))
	}
	if m.Digging != 0 {
		n += 2 + sovTypes(uint64(m.Digging))
	}
	if m.Mining != 0 {
		n += 2 + sovTypes(uint64(m.Mining))
	}
	if m.PiercingProtection != 0 {
		n += 2 + sovTypes(uint64(m.PiercingProtection))
	}
	if m.BluntProtection != 0 {
		n += 2 + sovTypes(uint64(m.BluntProtection))
	}
	if m.Insulation != 0 {
		n += 2 + sovTypes(uint64(m.Insulation))
	}
	if m.Strength != 0 {
		n += 2 + sovTypes(uint64(m.Strength))
	}
	return n
}

func (m *MaterialDefinition) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Metallic {
		n += 2
	}
	if m.Wooden {
		n += 2
	}
	if m.Fleshy {
		n += 2
	}
	if m.Salty {
		n += 2
	}
	if m.PH != 0 {
		n += 2 + sovTypes(uint64(m.PH))
	}
	if m.SolidAt != 0 {
		n += 2 + sovTypes(uint64(m.SolidAt))
	}
	if m.GasAt != 0 {
		n += 2 + sovTypes(uint64(m.GasAt))
	}
	if m.Sharpness != 0 {
		n += 2 + sovTypes(uint64(m.Sharpness))
	}
	if m.Heft != 0 {
		n += 2 + sovTypes(uint64(m.Heft))
	}
	if m.Strength != 0 {
		n += 2 + sovTypes(uint64(m.Strength))
	}
	return n
}

func (m *PrimitiveMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Primitive) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Primitive_String_) Size() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Primitive_Int) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Int))
	return n
}
func (m *Primitive_Bool) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Primitive_Float) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *Nothing) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Age) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Age: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Age: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticks", wireType)
			}
			m.Ticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ticks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Auth) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Auth: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Auth: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityId", wireType)
			}
			m.EntityId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntityId |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = append(m.Password[:0], dAtA[iNdEx:postIndex]...)
			if m.Password == nil {
				m.Password = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoggedIn = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spawn == nil {
				m.Spawn = &AbsolutePoint{}
			}
			if err := m.Spawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Players) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Players: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Players: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[string]*Player)
			}
			var mapkey string
			var mapvalue *Player
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Player{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Address) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Address: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Address: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addr", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Addr = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &Entity{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Voxels = append(m.Voxels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Voxels = append(m.Voxels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxels", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compound == nil {
				m.Compound = make(map[uint32]*Chunk_Compound)
			}
			var mapkey uint32
			var mapvalue *Chunk_Compound
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Chunk_Compound{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Compound[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Entities = append(m.Entities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Entities = append(m.Entities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Chunk_ItemAtPoint{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ActiveVoxels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ActiveVoxels = append(m.ActiveVoxels, &Point{})
			if err := m.ActiveVoxels[len(m.ActiveVoxels)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_Compound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Compound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Compound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiblockChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiblockChunk == nil {
				m.MultiblockChunk = &Point{}
			}
			if err := m.MultiblockChunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_ItemAtPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemAtPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemAtPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &Item{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventorySlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventorySlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventorySlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerType", wireType)
			}
			m.ContainerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerType |= (InventorySlot_ContainerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AbsolutePoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ContainerLocation = &InventorySlot_Point{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainerLocation = &InventorySlot_EntityId{v}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Slots = append(m.Slots, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Slots = append(m.Slots, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			m.Control = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Control |= (Entity_Control(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &AbsolutePoint{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Form", wireType)
			}
			m.Form = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Form |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Material", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Substance = &Item_Material{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Item_Components{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Substance = &Item_Components_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &Item{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbsolutePoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbsolutePoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbsolutePoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &Point{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voxel == nil {
				m.Voxel = &Point{}
			}
			if err := m.Voxel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_MoveAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Move{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Craft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_CraftAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Craft{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_MoveAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhereTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WhereTo == nil {
				m.WhereTo = &AbsolutePoint{}
			}
			if err := m.WhereTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_CraftAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CraftAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CraftAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			m.Verb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verb |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectLocation == nil {
				m.ObjectLocation = &AbsolutePoint{}
			}
			if err := m.ObjectLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &InventorySlot{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputForms = append(m.OutputForms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputForms = append(m.OutputForms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputForms", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field E", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.E == nil {
				m.E = make(map[uint64]*EntityDefinition)
			}
			var mapkey uint64
			var mapvalue *EntityDefinition
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &EntityDefinition{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.E[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field V", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.V == nil {
				m.V = make(map[uint64]*VoxelDefinition)
			}
			var mapkey uint64
			var mapvalue *VoxelDefinition
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &VoxelDefinition{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.V[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field F", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.F == nil {
				m.F = make(map[uint64]*FormDefinition)
			}
			var mapkey uint64
			var mapvalue *FormDefinition
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &FormDefinition{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.F[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field M", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.M == nil {
				m.M = make(map[uint64]*MaterialDefinition)
			}
			var mapkey uint64
			var mapvalue *MaterialDefinition
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &MaterialDefinition{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.M[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Falls", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Falls = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InventoryCapacity", wireType)
			}
			m.InventoryCapacity = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InventoryCapacity |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoxelDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoxelDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoxelDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field State", wireType)
			}
			m.State = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.State |= (VoxelDefinition_State(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FormDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FormDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FormDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wieldable1Handed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wieldable1Handed = bool(v != 0)
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wieldable2Handed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wieldable2Handed = bool(v != 0)
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WearableSlot", wireType)
			}
			m.WearableSlot = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WearableSlot |= (FormDefinition_WearableSlot(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 300:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharpness", wireType)
			}
			m.Sharpness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sharpness |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 301:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heft", wireType)
			}
			m.Heft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Heft |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 302:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digging", wireType)
			}
			m.Digging = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Digging |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 303:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Mining", wireType)
			}
			m.Mining = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Mining |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 400:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PiercingProtection", wireType)
			}
			m.PiercingProtection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PiercingProtection |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 401:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BluntProtection", wireType)
			}
			m.BluntProtection = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BluntProtection |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 402:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Insulation", wireType)
			}
			m.Insulation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Insulation |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 500:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MaterialDefinition) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MaterialDefinition: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MaterialDefinition: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metallic", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Metallic = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Wooden", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Wooden = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fleshy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Fleshy = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salty", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Salty = bool(v != 0)
		case 100:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PH", wireType)
			}
			m.PH = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PH |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 101:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SolidAt", wireType)
			}
			m.SolidAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SolidAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 102:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GasAt", wireType)
			}
			m.GasAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GasAt |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 200:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sharpness", wireType)
			}
			m.Sharpness = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Sharpness |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 201:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Heft", wireType)
			}
			m.Heft = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Heft |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 202:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Strength", wireType)
			}
			m.Strength = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Strength |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*Primitive)
			}
			var mapkey string
			var mapvalue *Primitive
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Primitive{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primitive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primitive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primitive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Primitive_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Primitive_Int{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Primitive_Bool{b}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Primitive_Float{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nothing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nothing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nothing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1832 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x58, 0xcf, 0x6f, 0xdb, 0xc8,
	0xf5, 0x17, 0x45, 0x91, 0x92, 0x9e, 0x2d, 0x99, 0x9e, 0xf8, 0x9b, 0x2f, 0x57, 0x49, 0xbc, 0x2a,
	0xd1, 0x4d, 0x95, 0x34, 0x65, 0xb2, 0x5e, 0x20, 0x28, 0x8a, 0x5e, 0x64, 0x47, 0x8e, 0x8c, 0x5a,
	0xae, 0x3a, 0x36, 0x92, 0xee, 0x91, 0x96, 0x46, 0xf2, 0xac, 0x29, 0x92, 0x25, 0x47, 0x4a, 0xb4,
	0x28, 0xd0, 0x63, 0xaf, 0xdd, 0x02, 0x2d, 0x0a, 0xb4, 0xb7, 0x5e, 0x7a, 0xe8, 0x8f, 0x53, 0xff,
	0x87, 0xb4, 0xa7, 0xfe, 0x09, 0x45, 0x7a, 0xe8, 0xb9, 0x40, 0x51, 0xa0, 0xb7, 0x62, 0x7e, 0x90,
	0x22, 0x65, 0x79, 0x8b, 0x5e, 0x92, 0x79, 0x9f, 0xcf, 0xe3, 0xe3, 0xe3, 0x67, 0xde, 0x7b, 0x33,
	0x32, 0xec, 0xb2, 0x65, 0x44, 0x92, 0xa7, 0xe2, 0x5f, 0x37, 0x8a, 0x43, 0x16, 0x3a, 0xf7, 0x40,
	0xef, 0x4e, 0x09, 0xda, 0x03, 0x83, 0xd1, 0xd1, 0x75, 0x62, 0x6b, 0x6d, 0xad, 0x53, 0xc1, 0xd2,
	0x70, 0x9e, 0x43, 0xa5, 0x3b, 0x67, 0x57, 0x08, 0x41, 0x25, 0xf0, 0x66, 0x44, 0x90, 0x75, 0x2c,
	0xd6, 0xa8, 0x05, 0xb5, 0xc8, 0x4b, 0x92, 0x37, 0x61, 0x3c, 0xb6, 0xcb, 0x6d, 0xad, 0xb3, 0x8d,
	0x33, 0xdb, 0xf9, 0xb9, 0x06, 0xe6, 0xd0, 0xf7, 0x96, 0x24, 0xe6, 0x6e, 0x24, 0x60, 0x94, 0x2d,
	0x4f, 0xc6, 0xe2, 0x71, 0x1d, 0x67, 0x76, 0x16, 0xb6, 0x7c, 0x4b, 0x58, 0xbd, 0x18, 0x96, 0x73,
	0x7e, 0x38, 0x9d, 0x92, 0xf1, 0x49, 0x60, 0x57, 0xda, 0x5a, 0xa7, 0x86, 0x33, 0x1b, 0x7d, 0x15,
	0x8c, 0x24, 0xf2, 0xde, 0x04, 0xb6, 0xd1, 0xd6, 0x3a, 0x5b, 0x07, 0x4d, 0xb7, 0x7b, 0x99, 0x84,
	0xfe, 0x9c, 0x91, 0x61, 0x48, 0x03, 0x86, 0x25, 0xe9, 0xfc, 0x08, 0xaa, 0x32, 0xaf, 0x04, 0x3d,
	0x85, 0x6a, 0x24, 0x97, 0xb6, 0xd6, 0xd6, 0x3b, 0x5b, 0x07, 0xff, 0xe7, 0x2a, 0x2a, 0xfd, 0xbf,
	0x17, 0xb0, 0x78, 0x89, 0x53, 0xaf, 0xd6, 0x11, 0x6c, 0xe7, 0x09, 0x64, 0x81, 0x7e, 0x4d, 0x96,
	0x4a, 0x13, 0xbe, 0x44, 0x0f, 0xc0, 0x58, 0x78, 0xfe, 0x5c, 0x7e, 0xd0, 0xd6, 0x41, 0x55, 0x05,
	0xc2, 0x12, 0xfd, 0x56, 0xf9, 0x9b, 0x9a, 0xe3, 0x00, 0x48, 0xf0, 0x94, 0x26, 0x8c, 0xab, 0xce,
	0x3f, 0x5a, 0x66, 0x50, 0xc7, 0xd2, 0x70, 0xda, 0xa9, 0xcf, 0x19, 0x17, 0x64, 0x83, 0xf6, 0xce,
	0x03, 0xa8, 0x76, 0xc7, 0xe3, 0x98, 0x24, 0x09, 0xa7, 0xbd, 0xf1, 0x38, 0x4e, 0x69, 0xbe, 0x76,
	0xbe, 0x07, 0x0d, 0x19, 0xe0, 0x05, 0x61, 0x1e, 0xf5, 0x13, 0xf4, 0x21, 0x98, 0xf2, 0x2b, 0x84,
	0x5b, 0x2e, 0x33, 0x05, 0x73, 0x07, 0xb9, 0x2b, 0x59, 0xea, 0x3d, 0x61, 0x62, 0x05, 0x3b, 0xff,
	0xd0, 0xc1, 0x38, 0xba, 0x9a, 0x07, 0xd7, 0xe8, 0x2e, 0x98, 0x8b, 0xf0, 0x2d, 0xf1, 0x65, 0xd2,
	0x15, 0xac, 0x2c, 0xf4, 0x0c, 0x6a, 0xa3, 0x70, 0x16, 0x85, 0xf3, 0x80, 0xd7, 0x03, 0x17, 0x74,
	0xcf, 0x15, 0x4f, 0xb8, 0x47, 0x0a, 0x96, 0x7a, 0x66, 0x5e, 0x59, 0x69, 0x50, 0x92, 0xd8, 0x7a,
	0x5b, 0xcf, 0x4a, 0x83, 0x92, 0x04, 0x75, 0xc0, 0xa0, 0x8c, 0xcc, 0x12, 0xbb, 0x22, 0x42, 0x21,
	0x15, 0xea, 0x84, 0x91, 0x59, 0x97, 0xa9, 0x2d, 0x15, 0x0e, 0xe8, 0x31, 0x6c, 0x7b, 0x23, 0x46,
	0x17, 0xe4, 0x95, 0xcc, 0xca, 0x10, 0x0f, 0x98, 0xae, 0x74, 0x2a, 0x70, 0xad, 0x9f, 0x69, 0x50,
	0x4b, 0xb3, 0x41, 0x1d, 0xa8, 0xd3, 0x60, 0x41, 0x02, 0x16, 0xc6, 0x4b, 0xa5, 0x0b, 0xb8, 0x27,
	0x29, 0x82, 0x57, 0x24, 0xfa, 0x06, 0x40, 0x14, 0x87, 0x11, 0x89, 0x45, 0xaa, 0x52, 0xa1, 0x86,
	0x3b, 0x8c, 0xe9, 0x8c, 0xf2, 0xe0, 0x03, 0x2f, 0xc2, 0x39, 0x07, 0xf4, 0x0c, 0x76, 0x66, 0x73,
	0x9f, 0xd1, 0x4b, 0x3f, 0x1c, 0x5d, 0x8b, 0xbc, 0x45, 0x25, 0xaf, 0x92, 0x5a, 0xa7, 0x5b, 0xa7,
	0xd0, 0x28, 0x88, 0x94, 0xaf, 0xad, 0x86, 0xac, 0xad, 0x8f, 0x8a, 0xb5, 0xb5, 0xb3, 0xa6, 0x6d,
	0xae, 0xc6, 0x5a, 0xc7, 0xb0, 0x95, 0xd3, 0x09, 0xdd, 0x07, 0x23, 0xe2, 0x0b, 0xf5, 0x8d, 0x69,
	0x12, 0x12, 0x44, 0x1f, 0x40, 0x85, 0xeb, 0xa8, 0xc2, 0x1a, 0x42, 0x61, 0x2c, 0x20, 0xa7, 0x03,
	0xf5, 0x4c, 0x0e, 0x74, 0x2f, 0xdd, 0x10, 0xd9, 0x2c, 0xca, 0x51, 0x62, 0xce, 0xbf, 0x34, 0x68,
	0x64, 0xae, 0xe7, 0x7e, 0xc8, 0xd0, 0x21, 0x34, 0x46, 0x61, 0xc0, 0x3c, 0x1a, 0x90, 0xf8, 0x62,
	0x19, 0xc9, 0xf2, 0x6d, 0x1e, 0xdc, 0x77, 0x0b, 0x6e, 0xee, 0x51, 0xde, 0x07, 0x17, 0x1f, 0x41,
	0x0f, 0xd3, 0xc4, 0xcb, 0x9b, 0x5a, 0xba, 0x5f, 0x4a, 0x3f, 0xe1, 0x7e, 0x6e, 0xc4, 0x70, 0xa1,
	0xf5, 0x7e, 0x29, 0x37, 0x64, 0xf6, 0xc0, 0x48, 0xfc, 0x90, 0xc9, 0x4a, 0x6a, 0x60, 0x69, 0x38,
	0xcf, 0xb8, 0xe2, 0xf9, 0x97, 0xd5, 0xc1, 0x78, 0xf5, 0xdd, 0xef, 0xf7, 0x4e, 0xad, 0x12, 0x02,
	0x30, 0x7b, 0x67, 0x17, 0x27, 0x17, 0x9f, 0x5a, 0x1a, 0xaa, 0x41, 0xe5, 0xe4, 0xa2, 0x37, 0xb0,
	0xca, 0x87, 0x77, 0x60, 0x37, 0x4b, 0xef, 0x34, 0x1c, 0x79, 0x8c, 0x86, 0x81, 0xf3, 0xab, 0x32,
	0x98, 0xb2, 0x53, 0x50, 0x13, 0xca, 0x34, 0x1d, 0x71, 0x65, 0x2a, 0x86, 0x1b, 0x9f, 0xb3, 0x22,
	0xf9, 0x0a, 0x16, 0x6b, 0xf4, 0x08, 0xaa, 0x3c, 0x46, 0x1c, 0xfa, 0x22, 0xd1, 0xe6, 0xc1, 0x8e,
	0xea, 0x33, 0x21, 0x44, 0x1c, 0xfa, 0x38, 0xe5, 0xd1, 0x63, 0x3e, 0xeb, 0xe4, 0x5b, 0xc4, 0xac,
	0xbb, 0x39, 0xd2, 0x32, 0x7e, 0xad, 0x3e, 0x8d, 0xff, 0x56, 0x9f, 0x85, 0xc2, 0x37, 0xbf, 0xac,
	0xf0, 0xf7, 0x01, 0xa2, 0x6c, 0x12, 0xd9, 0x55, 0x31, 0x62, 0x72, 0x88, 0xb3, 0x0f, 0x55, 0x95,
	0x38, 0x17, 0x6d, 0x78, 0xda, 0xfd, 0xb4, 0x87, 0xad, 0x12, 0xaa, 0x82, 0x7e, 0x36, 0x3c, 0xb2,
	0x34, 0xa7, 0x05, 0xb5, 0x5e, 0xba, 0x0f, 0x6b, 0xfa, 0x38, 0x3f, 0x2e, 0x43, 0x85, 0xd7, 0x10,
	0x17, 0x6a, 0x12, 0xc6, 0x33, 0x55, 0xec, 0x62, 0xcd, 0xb7, 0x74, 0xe6, 0x31, 0x12, 0x53, 0xcf,
	0x17, 0x02, 0x36, 0xf8, 0x96, 0xa6, 0x08, 0x3a, 0x00, 0x10, 0x43, 0x24, 0x20, 0x01, 0x4b, 0x54,
	0x6f, 0x59, 0xa2, 0x20, 0x65, 0x3f, 0x08, 0xbc, 0x5f, 0xc2, 0x39, 0xaf, 0x35, 0x8d, 0x2a, 0xff,
	0x93, 0x46, 0xc6, 0x97, 0x68, 0xd4, 0xfa, 0x04, 0x60, 0xf5, 0x52, 0xf4, 0x51, 0x21, 0xb5, 0x42,
	0xaf, 0xe4, 0x88, 0xc3, 0x2d, 0xa8, 0x27, 0xf3, 0xcb, 0x84, 0x79, 0xc1, 0x88, 0x38, 0xdf, 0x81,
	0x46, 0x61, 0x67, 0x79, 0xc7, 0x8e, 0xc4, 0xd8, 0x58, 0xeb, 0x58, 0x01, 0x72, 0x56, 0x8c, 0x5c,
	0xd5, 0x16, 0x19, 0x2b, 0x40, 0xe7, 0x63, 0x30, 0x64, 0x90, 0x6d, 0xd0, 0xde, 0x2a, 0xb9, 0xb5,
	0xb7, 0xdc, 0x92, 0xb3, 0x5d, 0xc7, 0xda, 0x92, 0x5b, 0x9f, 0xcb, 0x56, 0xc1, 0xda, 0xe7, 0xce,
	0x13, 0xa8, 0x76, 0x47, 0xbc, 0x90, 0x12, 0xf4, 0x15, 0xa8, 0x7a, 0x72, 0xa9, 0x72, 0xaf, 0xba,
	0x92, 0xc2, 0x29, 0xee, 0xfc, 0xbd, 0x0c, 0xa6, 0xc4, 0xd6, 0xca, 0x43, 0x5b, 0x2f, 0x0f, 0xd4,
	0x81, 0xca, 0x2c, 0x5c, 0xa4, 0x23, 0x0b, 0xa9, 0x50, 0xee, 0x20, 0x5c, 0x10, 0xb9, 0xec, 0x97,
	0xb0, 0xf0, 0x40, 0x5f, 0x07, 0x63, 0x14, 0x7b, 0x13, 0xa6, 0x36, 0xf3, 0x4e, 0xea, 0x7a, 0xc4,
	0xc1, 0xcc, 0x57, 0xfa, 0xb4, 0x9e, 0x03, 0xac, 0x42, 0xa0, 0x0e, 0x54, 0xdf, 0x5c, 0x91, 0x98,
	0x5c, 0x84, 0x4a, 0xae, 0xf5, 0x3e, 0x49, 0xe9, 0xd6, 0xaf, 0x35, 0xd8, 0xca, 0x05, 0xe4, 0x85,
	0xb7, 0x20, 0xf1, 0x65, 0x5a, 0x78, 0x7c, 0x8d, 0x9e, 0x43, 0x33, 0xbc, 0xfc, 0x8c, 0x8c, 0x58,
	0xda, 0xe2, 0x9b, 0x87, 0x0f, 0x5e, 0xf3, 0x42, 0x0f, 0xc1, 0xa4, 0x41, 0x34, 0x67, 0xf2, 0x24,
	0xe3, 0xfe, 0x85, 0x41, 0x87, 0x15, 0x8b, 0xda, 0xb0, 0x15, 0xce, 0x59, 0x34, 0x67, 0xc7, 0x61,
	0x3c, 0x4b, 0x67, 0x52, 0x1e, 0x3a, 0xac, 0x81, 0x29, 0xa5, 0x76, 0x7e, 0xa3, 0xcb, 0xf6, 0x22,
	0x01, 0x43, 0x0f, 0x40, 0x23, 0x6a, 0x4b, 0x76, 0x5c, 0x05, 0xba, 0x3d, 0x79, 0xa2, 0x6a, 0x84,
	0xd3, 0x0b, 0x75, 0xea, 0xae, 0xe8, 0x57, 0x8a, 0x5e, 0x70, 0x7a, 0xa2, 0x12, 0x5b, 0xd1, 0xc7,
	0x8a, 0x9e, 0x70, 0x7a, 0xa6, 0x0e, 0xda, 0x15, 0x3d, 0x50, 0xf4, 0xac, 0xf5, 0x12, 0xcc, 0xde,
	0x8d, 0x63, 0xa9, 0x22, 0x8f, 0xa5, 0xaf, 0x15, 0x8f, 0xa5, 0x5d, 0x35, 0xcf, 0x5e, 0x90, 0x09,
	0x0d, 0xa8, 0x28, 0x9c, 0xc2, 0xc1, 0x64, 0xbe, 0xba, 0x2d, 0xd0, 0xc3, 0x62, 0x20, 0xcb, 0x15,
	0x47, 0xf6, 0xe6, 0x38, 0x3d, 0x30, 0x8f, 0x6f, 0x8b, 0x73, 0xe3, 0x9c, 0xe4, 0xaa, 0x6e, 0x0e,
	0x73, 0x02, 0xe6, 0xe0, 0xb6, 0x30, 0x8f, 0x8a, 0x61, 0xee, 0xb8, 0x03, 0x35, 0x7c, 0x36, 0x86,
	0x72, 0x3e, 0x03, 0x6b, 0xfd, 0xc3, 0x37, 0x5e, 0x9a, 0xf7, 0xc0, 0x98, 0x78, 0xbe, 0x2f, 0x2f,
	0x11, 0x35, 0x2c, 0x0d, 0xf4, 0x04, 0x76, 0xb3, 0x79, 0x72, 0xe4, 0x45, 0xde, 0x88, 0x5f, 0xc4,
	0x74, 0x91, 0xcc, 0x4d, 0xc2, 0xf9, 0x42, 0x83, 0x9d, 0x35, 0x71, 0x36, 0xbe, 0xeb, 0x09, 0x18,
	0x09, 0xf3, 0x98, 0xfc, 0x84, 0xe6, 0xc1, 0xdd, 0x75, 0x45, 0xdd, 0x73, 0xce, 0x62, 0xe9, 0xe4,
	0x7c, 0x1b, 0x0c, 0x61, 0xa3, 0x26, 0x00, 0xa6, 0x53, 0x3a, 0x3e, 0x0f, 0x7d, 0x3a, 0xb6, 0x4a,
	0xdc, 0x3e, 0x0d, 0xc3, 0x84, 0x48, 0x5b, 0xe3, 0x83, 0xfe, 0x94, 0xfe, 0x60, 0x4e, 0xc7, 0x56,
	0x99, 0x0f, 0xfa, 0x97, 0x5e, 0x62, 0xe9, 0xce, 0xbf, 0x2b, 0xd0, 0x2c, 0x0a, 0xbd, 0x31, 0xa5,
	0xc7, 0x60, 0xbd, 0xa6, 0xc4, 0x1f, 0x7b, 0x97, 0x3e, 0xf9, 0xb8, 0xef, 0x05, 0x63, 0x32, 0xb6,
	0xc7, 0x42, 0x89, 0x1b, 0x78, 0xc1, 0xf7, 0x40, 0xf9, 0x92, 0x35, 0x5f, 0x85, 0xa3, 0x2e, 0x6c,
	0xbf, 0x21, 0x5e, 0xcc, 0x21, 0xde, 0x6d, 0xf6, 0xbb, 0xf4, 0xb6, 0x51, 0xcc, 0xc9, 0x7d, 0x9d,
	0x73, 0xc2, 0x85, 0x47, 0xd0, 0x03, 0xa8, 0x9f, 0x5f, 0x79, 0x71, 0x14, 0x90, 0x24, 0xb1, 0x7f,
	0x2b, 0xce, 0x1c, 0xbc, 0x42, 0xd0, 0x1d, 0xa8, 0xf4, 0xc9, 0x84, 0xd9, 0xbf, 0x93, 0x8c, 0x30,
	0xd0, 0x07, 0x50, 0x7d, 0x41, 0xa7, 0x53, 0x1a, 0x4c, 0xed, 0xdf, 0x4b, 0x3c, 0xb5, 0xd1, 0xff,
	0x83, 0x39, 0xa0, 0x01, 0x67, 0xfe, 0x20, 0x19, 0x65, 0xa2, 0xa7, 0x80, 0x86, 0x94, 0xc4, 0x23,
	0x1a, 0x4c, 0x87, 0x71, 0xc8, 0x88, 0x68, 0x75, 0xfb, 0x27, 0xba, 0x70, 0xda, 0x40, 0xa1, 0x47,
	0xb0, 0x73, 0xe8, 0xcf, 0x03, 0x96, 0xf3, 0xfe, 0x42, 0x7a, 0xaf, 0xe3, 0xe8, 0x43, 0x80, 0x93,
	0x20, 0x99, 0xfb, 0x72, 0x70, 0xfd, 0x54, 0x7a, 0xe5, 0x20, 0x74, 0x0f, 0x6a, 0xe7, 0x2c, 0x26,
	0xc1, 0x94, 0x5d, 0xd9, 0xff, 0x94, 0x74, 0x06, 0x38, 0x7f, 0xd4, 0x60, 0x3b, 0x2f, 0x10, 0xb2,
	0x56, 0x76, 0x9f, 0x78, 0xbc, 0x16, 0x76, 0xa1, 0x91, 0x22, 0x47, 0x57, 0x24, 0x61, 0x96, 0x96,
	0x87, 0xf8, 0x66, 0x24, 0x56, 0x39, 0xff, 0xdc, 0x29, 0x99, 0x26, 0x96, 0x9e, 0x47, 0x8e, 0x09,
	0x61, 0x56, 0x05, 0x21, 0x68, 0x66, 0x08, 0x0d, 0xa6, 0x24, 0xb6, 0x8c, 0xbc, 0xd7, 0x19, 0x19,
	0x5d, 0x5b, 0x66, 0x1e, 0xe9, 0x2d, 0x49, 0x62, 0x55, 0xf3, 0xaf, 0x7b, 0xed, 0xd1, 0x84, 0x59,
	0x35, 0xe7, 0x97, 0x65, 0x40, 0x37, 0xbb, 0xf3, 0xb6, 0xdf, 0xac, 0x03, 0xc2, 0x3c, 0xdf, 0xa7,
	0x23, 0xd5, 0x81, 0x99, 0xcd, 0x7f, 0xd7, 0xbc, 0x0e, 0xc3, 0x31, 0x09, 0x44, 0xe7, 0xd5, 0xb0,
	0xb2, 0x38, 0x7e, 0xec, 0x93, 0xe4, 0x6a, 0xa9, 0x7e, 0x72, 0x2a, 0x8b, 0xb7, 0xf2, 0xb9, 0xe7,
	0x33, 0x79, 0x3b, 0xa8, 0x61, 0x69, 0xf0, 0x5b, 0xce, 0xb0, 0x2f, 0x6a, 0xba, 0x81, 0xcb, 0xc3,
	0x3e, 0xb2, 0xa1, 0x2a, 0x1a, 0xa7, 0xcb, 0x44, 0xf1, 0x36, 0x70, 0x6a, 0xf2, 0xe7, 0x5f, 0x7a,
	0x49, 0x97, 0xd9, 0x13, 0x81, 0x4b, 0xa3, 0x58, 0x86, 0xef, 0xb4, 0xdb, 0xca, 0xf0, 0x4f, 0x5a,
	0xae, 0x0c, 0xf3, 0xbb, 0xfa, 0x67, 0x6d, 0x6d, 0x57, 0x7f, 0x08, 0xdb, 0xf9, 0x4b, 0x0e, 0xea,
	0x80, 0x3e, 0xf3, 0x22, 0x75, 0x94, 0xdc, 0x2d, 0x5c, 0x80, 0xdc, 0x81, 0x17, 0xc9, 0xa1, 0xcf,
	0x5d, 0x5a, 0x87, 0x50, 0x4b, 0x81, 0x0d, 0xbf, 0x75, 0xdb, 0xc5, 0x01, 0x09, 0xab, 0x48, 0xf9,
	0xb9, 0x18, 0x41, 0x3d, 0xc3, 0x91, 0x0d, 0x66, 0xc2, 0x62, 0xde, 0x13, 0x22, 0x4e, 0xbf, 0x84,
	0x95, 0x8d, 0x10, 0xe8, 0xe9, 0x3d, 0x9f, 0x5f, 0xde, 0xb9, 0x81, 0xf6, 0xa0, 0x72, 0x19, 0xaa,
	0x8b, 0x72, 0x8d, 0x5f, 0x14, 0xb8, 0x85, 0xee, 0x82, 0x31, 0xf1, 0x43, 0x8f, 0x89, 0xcd, 0x28,
	0xf3, 0x3b, 0x81, 0x30, 0x0f, 0xab, 0x2a, 0x1d, 0xa7, 0x0e, 0xd5, 0xb3, 0x90, 0x5d, 0xd1, 0x60,
	0x7a, 0x68, 0xbd, 0x7b, 0xbf, 0xaf, 0xfd, 0xe5, 0xfd, 0xbe, 0xf6, 0xd7, 0xf7, 0xfb, 0xda, 0x2f,
	0xfe, 0xb6, 0x5f, 0xba, 0x34, 0xc5, 0xdf, 0x3c, 0x3e, 0xf9, 0x4f, 0x00, 0x00, 0x00, 0xff, 0xff,
	0x22, 0x91, 0x96, 0x87, 0x08, 0x11, 0x00, 0x00,
}
