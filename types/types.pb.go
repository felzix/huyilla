// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		Age
		Config
		Player
		Players
		PlayerList
		PlayerName
		PlayerDetails
		Chunk
		Inventory
		InventorySlot
		Entity
		EntityId
		Item
		AbsolutePoint
		Point
		Actions
		Action
		Content
		AllContent
		PrimitiveMap
		Primitive
		Nothing
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InventorySlot_ContainerType int32

const (
	InventorySlot_VOXEL  InventorySlot_ContainerType = 0
	InventorySlot_ENTITY InventorySlot_ContainerType = 1
	InventorySlot_ITEM   InventorySlot_ContainerType = 2
)

var InventorySlot_ContainerType_name = map[int32]string{
	0: "VOXEL",
	1: "ENTITY",
	2: "ITEM",
}
var InventorySlot_ContainerType_value = map[string]int32{
	"VOXEL":  0,
	"ENTITY": 1,
	"ITEM":   2,
}

func (x InventorySlot_ContainerType) String() string {
	return proto.EnumName(InventorySlot_ContainerType_name, int32(x))
}
func (InventorySlot_ContainerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{9, 0}
}

type Entity_Control int32

const (
	Entity_PLAYER Entity_Control = 0
	Entity_NPC    Entity_Control = 1
)

var Entity_Control_name = map[int32]string{
	0: "PLAYER",
	1: "NPC",
}
var Entity_Control_value = map[string]int32{
	"PLAYER": 0,
	"NPC":    1,
}

func (x Entity_Control) String() string {
	return proto.EnumName(Entity_Control_name, int32(x))
}
func (Entity_Control) EnumDescriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10, 0} }

type Age struct {
	Ticks uint64 `protobuf:"varint,1,opt,name=ticks,proto3" json:"ticks,omitempty"`
}

func (m *Age) Reset()                    { *m = Age{} }
func (m *Age) String() string            { return proto.CompactTextString(m) }
func (*Age) ProtoMessage()               {}
func (*Age) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Age) GetTicks() uint64 {
	if m != nil {
		return m.Ticks
	}
	return 0
}

type Config struct {
	Options *PrimitiveMap `protobuf:"bytes,1,opt,name=options" json:"options,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *Config) GetOptions() *PrimitiveMap {
	if m != nil {
		return m.Options
	}
	return nil
}

type Player struct {
	Id       int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Address  []byte         `protobuf:"bytes,2,opt,name=address,proto3" json:"address,omitempty"`
	Name     string         `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	LoggedIn bool           `protobuf:"varint,4,opt,name=loggedIn,proto3" json:"loggedIn,omitempty"`
	Spawn    *AbsolutePoint `protobuf:"bytes,5,opt,name=spawn" json:"spawn,omitempty"`
}

func (m *Player) Reset()                    { *m = Player{} }
func (m *Player) String() string            { return proto.CompactTextString(m) }
func (*Player) ProtoMessage()               {}
func (*Player) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *Player) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Player) GetAddress() []byte {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Player) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Player) GetLoggedIn() bool {
	if m != nil {
		return m.LoggedIn
	}
	return false
}

func (m *Player) GetSpawn() *AbsolutePoint {
	if m != nil {
		return m.Spawn
	}
	return nil
}

type Players struct {
	Players map[string]*Player `protobuf:"bytes,1,rep,name=players" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Players) Reset()                    { *m = Players{} }
func (m *Players) String() string            { return proto.CompactTextString(m) }
func (*Players) ProtoMessage()               {}
func (*Players) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *Players) GetPlayers() map[string]*Player {
	if m != nil {
		return m.Players
	}
	return nil
}

type PlayerList struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *PlayerList) Reset()                    { *m = PlayerList{} }
func (m *PlayerList) String() string            { return proto.CompactTextString(m) }
func (*PlayerList) ProtoMessage()               {}
func (*PlayerList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *PlayerList) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type PlayerName struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PlayerName) Reset()                    { *m = PlayerName{} }
func (m *PlayerName) String() string            { return proto.CompactTextString(m) }
func (*PlayerName) ProtoMessage()               {}
func (*PlayerName) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *PlayerName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type PlayerDetails struct {
	Player *Player `protobuf:"bytes,1,opt,name=player" json:"player,omitempty"`
	Entity *Entity `protobuf:"bytes,2,opt,name=entity" json:"entity,omitempty"`
}

func (m *PlayerDetails) Reset()                    { *m = PlayerDetails{} }
func (m *PlayerDetails) String() string            { return proto.CompactTextString(m) }
func (*PlayerDetails) ProtoMessage()               {}
func (*PlayerDetails) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *PlayerDetails) GetPlayer() *Player {
	if m != nil {
		return m.Player
	}
	return nil
}

func (m *PlayerDetails) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

type Chunk struct {
	Voxels   []uint64                   `protobuf:"varint,1,rep,packed,name=voxels" json:"voxels,omitempty"`
	Compound map[uint32]*Chunk_Compound `protobuf:"bytes,2,rep,name=compound" json:"compound,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Entities []int64                    `protobuf:"varint,3,rep,packed,name=entities" json:"entities,omitempty"`
	Items    []*Chunk_ItemAtPoint       `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *Chunk) GetVoxels() []uint64 {
	if m != nil {
		return m.Voxels
	}
	return nil
}

func (m *Chunk) GetCompound() map[uint32]*Chunk_Compound {
	if m != nil {
		return m.Compound
	}
	return nil
}

func (m *Chunk) GetEntities() []int64 {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Chunk) GetItems() []*Chunk_ItemAtPoint {
	if m != nil {
		return m.Items
	}
	return nil
}

type Chunk_Compound struct {
	Inventory       *Inventory    `protobuf:"bytes,1,opt,name=inventory" json:"inventory,omitempty"`
	Properties      *PrimitiveMap `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	MultiblockChunk *Point        `protobuf:"bytes,3,opt,name=multiblockChunk" json:"multiblockChunk,omitempty"`
}

func (m *Chunk_Compound) Reset()                    { *m = Chunk_Compound{} }
func (m *Chunk_Compound) String() string            { return proto.CompactTextString(m) }
func (*Chunk_Compound) ProtoMessage()               {}
func (*Chunk_Compound) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7, 0} }

func (m *Chunk_Compound) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Chunk_Compound) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Chunk_Compound) GetMultiblockChunk() *Point {
	if m != nil {
		return m.MultiblockChunk
	}
	return nil
}

type Chunk_ItemAtPoint struct {
	Point *Point `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Item  *Item  `protobuf:"bytes,2,opt,name=item" json:"item,omitempty"`
}

func (m *Chunk_ItemAtPoint) Reset()                    { *m = Chunk_ItemAtPoint{} }
func (m *Chunk_ItemAtPoint) String() string            { return proto.CompactTextString(m) }
func (*Chunk_ItemAtPoint) ProtoMessage()               {}
func (*Chunk_ItemAtPoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7, 2} }

func (m *Chunk_ItemAtPoint) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *Chunk_ItemAtPoint) GetItem() *Item {
	if m != nil {
		return m.Item
	}
	return nil
}

type Inventory struct {
	Items []*Item `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *Inventory) Reset()                    { *m = Inventory{} }
func (m *Inventory) String() string            { return proto.CompactTextString(m) }
func (*Inventory) ProtoMessage()               {}
func (*Inventory) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

func (m *Inventory) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type InventorySlot struct {
	ContainerType InventorySlot_ContainerType `protobuf:"varint,1,opt,name=containerType,proto3,enum=InventorySlot_ContainerType" json:"containerType,omitempty"`
	// Types that are valid to be assigned to ContainerLocation:
	//	*InventorySlot_Point
	//	*InventorySlot_EntityId
	ContainerLocation isInventorySlot_ContainerLocation `protobuf_oneof:"containerLocation"`
	Slots             []uint32                          `protobuf:"varint,4,rep,packed,name=slots" json:"slots,omitempty"`
}

func (m *InventorySlot) Reset()                    { *m = InventorySlot{} }
func (m *InventorySlot) String() string            { return proto.CompactTextString(m) }
func (*InventorySlot) ProtoMessage()               {}
func (*InventorySlot) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isInventorySlot_ContainerLocation interface {
	isInventorySlot_ContainerLocation()
	MarshalTo([]byte) (int, error)
	Size() int
}

type InventorySlot_Point struct {
	Point *AbsolutePoint `protobuf:"bytes,2,opt,name=point,oneof"`
}
type InventorySlot_EntityId struct {
	EntityId int64 `protobuf:"varint,3,opt,name=entityId,proto3,oneof"`
}

func (*InventorySlot_Point) isInventorySlot_ContainerLocation()    {}
func (*InventorySlot_EntityId) isInventorySlot_ContainerLocation() {}

func (m *InventorySlot) GetContainerLocation() isInventorySlot_ContainerLocation {
	if m != nil {
		return m.ContainerLocation
	}
	return nil
}

func (m *InventorySlot) GetContainerType() InventorySlot_ContainerType {
	if m != nil {
		return m.ContainerType
	}
	return InventorySlot_VOXEL
}

func (m *InventorySlot) GetPoint() *AbsolutePoint {
	if x, ok := m.GetContainerLocation().(*InventorySlot_Point); ok {
		return x.Point
	}
	return nil
}

func (m *InventorySlot) GetEntityId() int64 {
	if x, ok := m.GetContainerLocation().(*InventorySlot_EntityId); ok {
		return x.EntityId
	}
	return 0
}

func (m *InventorySlot) GetSlots() []uint32 {
	if m != nil {
		return m.Slots
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*InventorySlot) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _InventorySlot_OneofMarshaler, _InventorySlot_OneofUnmarshaler, _InventorySlot_OneofSizer, []interface{}{
		(*InventorySlot_Point)(nil),
		(*InventorySlot_EntityId)(nil),
	}
}

func _InventorySlot_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*InventorySlot)
	// containerLocation
	switch x := m.ContainerLocation.(type) {
	case *InventorySlot_Point:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Point); err != nil {
			return err
		}
	case *InventorySlot_EntityId:
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.EntityId))
	case nil:
	default:
		return fmt.Errorf("InventorySlot.ContainerLocation has unexpected type %T", x)
	}
	return nil
}

func _InventorySlot_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*InventorySlot)
	switch tag {
	case 2: // containerLocation.point
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(AbsolutePoint)
		err := b.DecodeMessage(msg)
		m.ContainerLocation = &InventorySlot_Point{msg}
		return true, err
	case 3: // containerLocation.entityId
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.ContainerLocation = &InventorySlot_EntityId{int64(x)}
		return true, err
	default:
		return false, nil
	}
}

func _InventorySlot_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*InventorySlot)
	// containerLocation
	switch x := m.ContainerLocation.(type) {
	case *InventorySlot_Point:
		s := proto.Size(x.Point)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *InventorySlot_EntityId:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.EntityId))
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Entity struct {
	Id         int64          `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	Type       uint32         `protobuf:"varint,2,opt,name=type,proto3" json:"type,omitempty"`
	Control    Entity_Control `protobuf:"varint,3,opt,name=control,proto3,enum=Entity_Control" json:"control,omitempty"`
	Location   *AbsolutePoint `protobuf:"bytes,4,opt,name=location" json:"location,omitempty"`
	Properties *PrimitiveMap  `protobuf:"bytes,5,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory     `protobuf:"bytes,6,opt,name=inventory" json:"inventory,omitempty"`
	PlayerName string         `protobuf:"bytes,7,opt,name=playerName,proto3" json:"playerName,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *Entity) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *Entity) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Entity) GetControl() Entity_Control {
	if m != nil {
		return m.Control
	}
	return Entity_PLAYER
}

func (m *Entity) GetLocation() *AbsolutePoint {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *Entity) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Entity) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Entity) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

type EntityId struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *EntityId) Reset()                    { *m = EntityId{} }
func (m *EntityId) String() string            { return proto.CompactTextString(m) }
func (*EntityId) ProtoMessage()               {}
func (*EntityId) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *EntityId) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Item struct {
	Form uint32 `protobuf:"varint,1,opt,name=form,proto3" json:"form,omitempty"`
	// Types that are valid to be assigned to Substance:
	//	*Item_Material
	//	*Item_Components_
	Substance  isItem_Substance `protobuf_oneof:"substance"`
	Properties *PrimitiveMap    `protobuf:"bytes,4,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory       `protobuf:"bytes,5,opt,name=inventory" json:"inventory,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

type isItem_Substance interface {
	isItem_Substance()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Item_Material struct {
	Material uint32 `protobuf:"varint,2,opt,name=material,proto3,oneof"`
}
type Item_Components_ struct {
	Components *Item_Components `protobuf:"bytes,3,opt,name=components,oneof"`
}

func (*Item_Material) isItem_Substance()    {}
func (*Item_Components_) isItem_Substance() {}

func (m *Item) GetSubstance() isItem_Substance {
	if m != nil {
		return m.Substance
	}
	return nil
}

func (m *Item) GetForm() uint32 {
	if m != nil {
		return m.Form
	}
	return 0
}

func (m *Item) GetMaterial() uint32 {
	if x, ok := m.GetSubstance().(*Item_Material); ok {
		return x.Material
	}
	return 0
}

func (m *Item) GetComponents() *Item_Components {
	if x, ok := m.GetSubstance().(*Item_Components_); ok {
		return x.Components
	}
	return nil
}

func (m *Item) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Item) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Item) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Item_OneofMarshaler, _Item_OneofUnmarshaler, _Item_OneofSizer, []interface{}{
		(*Item_Material)(nil),
		(*Item_Components_)(nil),
	}
}

func _Item_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Material))
	case *Item_Components_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Components); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Item.Substance has unexpected type %T", x)
	}
	return nil
}

func _Item_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Item)
	switch tag {
	case 2: // substance.material
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Substance = &Item_Material{uint32(x)}
		return true, err
	case 3: // substance.components
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Item_Components)
		err := b.DecodeMessage(msg)
		m.Substance = &Item_Components_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Item_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Material))
	case *Item_Components_:
		s := proto.Size(x.Components)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Item_Components struct {
	Components []*Item `protobuf:"bytes,1,rep,name=components" json:"components,omitempty"`
}

func (m *Item_Components) Reset()                    { *m = Item_Components{} }
func (m *Item_Components) String() string            { return proto.CompactTextString(m) }
func (*Item_Components) ProtoMessage()               {}
func (*Item_Components) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12, 0} }

func (m *Item_Components) GetComponents() []*Item {
	if m != nil {
		return m.Components
	}
	return nil
}

type AbsolutePoint struct {
	Chunk *Point `protobuf:"bytes,1,opt,name=chunk" json:"chunk,omitempty"`
	Voxel *Point `protobuf:"bytes,2,opt,name=voxel" json:"voxel,omitempty"`
}

func (m *AbsolutePoint) Reset()                    { *m = AbsolutePoint{} }
func (m *AbsolutePoint) String() string            { return proto.CompactTextString(m) }
func (*AbsolutePoint) ProtoMessage()               {}
func (*AbsolutePoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

func (m *AbsolutePoint) GetChunk() *Point {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *AbsolutePoint) GetVoxel() *Point {
	if m != nil {
		return m.Voxel
	}
	return nil
}

type Point struct {
	X int64 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y int64 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	Z int64 `protobuf:"varint,3,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *Point) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Point) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type Actions struct {
	Actions []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
}

func (m *Actions) Reset()                    { *m = Actions{} }
func (m *Actions) String() string            { return proto.CompactTextString(m) }
func (*Actions) ProtoMessage()               {}
func (*Actions) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

func (m *Actions) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type Action struct {
	PlayerName string `protobuf:"bytes,1,opt,name=playerName,proto3" json:"playerName,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*Action_Move
	//	*Action_Craft
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Move struct {
	Move *Action_MoveAction `protobuf:"bytes,2,opt,name=move,oneof"`
}
type Action_Craft struct {
	Craft *Action_CraftAction `protobuf:"bytes,3,opt,name=craft,oneof"`
}

func (*Action_Move) isAction_Action()  {}
func (*Action_Craft) isAction_Action() {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

func (m *Action) GetMove() *Action_MoveAction {
	if x, ok := m.GetAction().(*Action_Move); ok {
		return x.Move
	}
	return nil
}

func (m *Action) GetCraft() *Action_CraftAction {
	if x, ok := m.GetAction().(*Action_Craft); ok {
		return x.Craft
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Action) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Action_OneofMarshaler, _Action_OneofUnmarshaler, _Action_OneofSizer, []interface{}{
		(*Action_Move)(nil),
		(*Action_Craft)(nil),
	}
}

func _Action_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Move); err != nil {
			return err
		}
	case *Action_Craft:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Craft); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Action.Action has unexpected type %T", x)
	}
	return nil
}

func _Action_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Action)
	switch tag {
	case 2: // action.move
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_MoveAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Move{msg}
		return true, err
	case 3: // action.craft
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_CraftAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Craft{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Action_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		s := proto.Size(x.Move)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Action_Craft:
		s := proto.Size(x.Craft)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Action_MoveAction struct {
	WhereTo *AbsolutePoint `protobuf:"bytes,1,opt,name=whereTo" json:"whereTo,omitempty"`
}

func (m *Action_MoveAction) Reset()                    { *m = Action_MoveAction{} }
func (m *Action_MoveAction) String() string            { return proto.CompactTextString(m) }
func (*Action_MoveAction) ProtoMessage()               {}
func (*Action_MoveAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16, 0} }

func (m *Action_MoveAction) GetWhereTo() *AbsolutePoint {
	if m != nil {
		return m.WhereTo
	}
	return nil
}

type Action_CraftAction struct {
	Verb           uint32           `protobuf:"varint,1,opt,name=verb,proto3" json:"verb,omitempty"`
	ObjectLocation *AbsolutePoint   `protobuf:"bytes,2,opt,name=objectLocation" json:"objectLocation,omitempty"`
	Inputs         []*InventorySlot `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
	OutputForms    []uint32         `protobuf:"varint,4,rep,packed,name=outputForms" json:"outputForms,omitempty"`
}

func (m *Action_CraftAction) Reset()                    { *m = Action_CraftAction{} }
func (m *Action_CraftAction) String() string            { return proto.CompactTextString(m) }
func (*Action_CraftAction) ProtoMessage()               {}
func (*Action_CraftAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16, 1} }

func (m *Action_CraftAction) GetVerb() uint32 {
	if m != nil {
		return m.Verb
	}
	return 0
}

func (m *Action_CraftAction) GetObjectLocation() *AbsolutePoint {
	if m != nil {
		return m.ObjectLocation
	}
	return nil
}

func (m *Action_CraftAction) GetInputs() []*InventorySlot {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Action_CraftAction) GetOutputForms() []uint32 {
	if m != nil {
		return m.OutputForms
	}
	return nil
}

type Content struct {
	Definitions map[uint32]*PrimitiveMap `protobuf:"bytes,1,rep,name=definitions" json:"definitions,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Content) Reset()                    { *m = Content{} }
func (m *Content) String() string            { return proto.CompactTextString(m) }
func (*Content) ProtoMessage()               {}
func (*Content) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{17} }

func (m *Content) GetDefinitions() map[uint32]*PrimitiveMap {
	if m != nil {
		return m.Definitions
	}
	return nil
}

type AllContent struct {
	Entity   *Content `protobuf:"bytes,1,opt,name=entity" json:"entity,omitempty"`
	Voxel    *Content `protobuf:"bytes,2,opt,name=voxel" json:"voxel,omitempty"`
	Form     *Content `protobuf:"bytes,3,opt,name=form" json:"form,omitempty"`
	Material *Content `protobuf:"bytes,4,opt,name=material" json:"material,omitempty"`
}

func (m *AllContent) Reset()                    { *m = AllContent{} }
func (m *AllContent) String() string            { return proto.CompactTextString(m) }
func (*AllContent) ProtoMessage()               {}
func (*AllContent) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{18} }

func (m *AllContent) GetEntity() *Content {
	if m != nil {
		return m.Entity
	}
	return nil
}

func (m *AllContent) GetVoxel() *Content {
	if m != nil {
		return m.Voxel
	}
	return nil
}

func (m *AllContent) GetForm() *Content {
	if m != nil {
		return m.Form
	}
	return nil
}

func (m *AllContent) GetMaterial() *Content {
	if m != nil {
		return m.Material
	}
	return nil
}

type PrimitiveMap struct {
	Map map[string]*Primitive `protobuf:"bytes,1,rep,name=map" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PrimitiveMap) Reset()                    { *m = PrimitiveMap{} }
func (m *PrimitiveMap) String() string            { return proto.CompactTextString(m) }
func (*PrimitiveMap) ProtoMessage()               {}
func (*PrimitiveMap) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{19} }

func (m *PrimitiveMap) GetMap() map[string]*Primitive {
	if m != nil {
		return m.Map
	}
	return nil
}

type Primitive struct {
	// Types that are valid to be assigned to Value:
	//	*Primitive_String_
	//	*Primitive_Int
	//	*Primitive_Bool
	//	*Primitive_Float
	Value isPrimitive_Value `protobuf_oneof:"value"`
}

func (m *Primitive) Reset()                    { *m = Primitive{} }
func (m *Primitive) String() string            { return proto.CompactTextString(m) }
func (*Primitive) ProtoMessage()               {}
func (*Primitive) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{20} }

type isPrimitive_Value interface {
	isPrimitive_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Primitive_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,proto3,oneof"`
}
type Primitive_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,proto3,oneof"`
}
type Primitive_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,proto3,oneof"`
}
type Primitive_Float struct {
	Float float32 `protobuf:"fixed32,4,opt,name=float,proto3,oneof"`
}

func (*Primitive_String_) isPrimitive_Value() {}
func (*Primitive_Int) isPrimitive_Value()     {}
func (*Primitive_Bool) isPrimitive_Value()    {}
func (*Primitive_Float) isPrimitive_Value()   {}

func (m *Primitive) GetValue() isPrimitive_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Primitive) GetString_() string {
	if x, ok := m.GetValue().(*Primitive_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Primitive) GetInt() int64 {
	if x, ok := m.GetValue().(*Primitive_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Primitive) GetBool() bool {
	if x, ok := m.GetValue().(*Primitive_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Primitive) GetFloat() float32 {
	if x, ok := m.GetValue().(*Primitive_Float); ok {
		return x.Float
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Primitive) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Primitive_OneofMarshaler, _Primitive_OneofUnmarshaler, _Primitive_OneofSizer, []interface{}{
		(*Primitive_String_)(nil),
		(*Primitive_Int)(nil),
		(*Primitive_Bool)(nil),
		(*Primitive_Float)(nil),
	}
}

func _Primitive_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *Primitive_Int:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *Primitive_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Primitive_Float:
		_ = b.EncodeVarint(4<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float)))
	case nil:
	default:
		return fmt.Errorf("Primitive.Value has unexpected type %T", x)
	}
	return nil
}

func _Primitive_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Primitive)
	switch tag {
	case 1: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Primitive_String_{x}
		return true, err
	case 2: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Int{int64(x)}
		return true, err
	case 3: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Bool{x != 0}
		return true, err
	case 4: // value.float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &Primitive_Float{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _Primitive_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Primitive_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Primitive_Bool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *Primitive_Float:
		n += proto.SizeVarint(4<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Nothing struct {
}

func (m *Nothing) Reset()                    { *m = Nothing{} }
func (m *Nothing) String() string            { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()               {}
func (*Nothing) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{21} }

func init() {
	proto.RegisterType((*Age)(nil), "Age")
	proto.RegisterType((*Config)(nil), "Config")
	proto.RegisterType((*Player)(nil), "Player")
	proto.RegisterType((*Players)(nil), "Players")
	proto.RegisterType((*PlayerList)(nil), "PlayerList")
	proto.RegisterType((*PlayerName)(nil), "PlayerName")
	proto.RegisterType((*PlayerDetails)(nil), "PlayerDetails")
	proto.RegisterType((*Chunk)(nil), "Chunk")
	proto.RegisterType((*Chunk_Compound)(nil), "Chunk.Compound")
	proto.RegisterType((*Chunk_ItemAtPoint)(nil), "Chunk.ItemAtPoint")
	proto.RegisterType((*Inventory)(nil), "Inventory")
	proto.RegisterType((*InventorySlot)(nil), "InventorySlot")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*EntityId)(nil), "EntityId")
	proto.RegisterType((*Item)(nil), "Item")
	proto.RegisterType((*Item_Components)(nil), "Item.Components")
	proto.RegisterType((*AbsolutePoint)(nil), "AbsolutePoint")
	proto.RegisterType((*Point)(nil), "Point")
	proto.RegisterType((*Actions)(nil), "Actions")
	proto.RegisterType((*Action)(nil), "Action")
	proto.RegisterType((*Action_MoveAction)(nil), "Action.MoveAction")
	proto.RegisterType((*Action_CraftAction)(nil), "Action.CraftAction")
	proto.RegisterType((*Content)(nil), "Content")
	proto.RegisterType((*AllContent)(nil), "AllContent")
	proto.RegisterType((*PrimitiveMap)(nil), "PrimitiveMap")
	proto.RegisterType((*Primitive)(nil), "Primitive")
	proto.RegisterType((*Nothing)(nil), "Nothing")
	proto.RegisterEnum("InventorySlot_ContainerType", InventorySlot_ContainerType_name, InventorySlot_ContainerType_value)
	proto.RegisterEnum("Entity_Control", Entity_Control_name, Entity_Control_value)
}
func (m *Age) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Age) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ticks != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ticks))
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Options.Size()))
		n1, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	if len(m.Address) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Address)))
		i += copy(dAtA[i:], m.Address)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if m.LoggedIn {
		dAtA[i] = 0x20
		i++
		if m.LoggedIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.Spawn != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Spawn.Size()))
		n2, err := m.Spawn.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	return i, nil
}

func (m *Players) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Players) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, _ := range m.Players {
			dAtA[i] = 0xa
			i++
			v := m.Players[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n3, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n3
			}
		}
	}
	return i, nil
}

func (m *PlayerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PlayerName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *PlayerDetails) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerDetails) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Player.Size()))
		n4, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if m.Entity != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Entity.Size()))
		n5, err := m.Entity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		dAtA7 := make([]byte, len(m.Voxels)*10)
		var j6 int
		for _, num := range m.Voxels {
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j6))
		i += copy(dAtA[i:], dAtA7[:j6])
	}
	if len(m.Compound) > 0 {
		for k, _ := range m.Compound {
			dAtA[i] = 0x12
			i++
			v := m.Compound[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n8, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n8
			}
		}
	}
	if len(m.Entities) > 0 {
		dAtA10 := make([]byte, len(m.Entities)*10)
		var j9 int
		for _, num1 := range m.Entities {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA10[j9] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j9++
			}
			dAtA10[j9] = uint8(num)
			j9++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j9))
		i += copy(dAtA[i:], dAtA10[:j9])
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chunk_Compound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_Compound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Inventory != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n11, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Properties != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n12, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	if m.MultiblockChunk != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MultiblockChunk.Size()))
		n13, err := m.MultiblockChunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	return i, nil
}

func (m *Chunk_ItemAtPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_ItemAtPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Point != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n14, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if m.Item != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n15, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	return i, nil
}

func (m *Inventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inventory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InventorySlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventorySlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		nn16, err := m.ContainerLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if len(m.Slots) > 0 {
		dAtA18 := make([]byte, len(m.Slots)*10)
		var j17 int
		for _, num := range m.Slots {
			for num >= 1<<7 {
				dAtA18[j17] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j17++
			}
			dAtA18[j17] = uint8(num)
			j17++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j17))
		i += copy(dAtA[i:], dAtA18[:j17])
	}
	return i, nil
}

func (m *InventorySlot_Point) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Point != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n19, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *InventorySlot_EntityId) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.EntityId))
	return i, nil
}
func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	if m.Type != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Control != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Control))
	}
	if m.Location != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Location.Size()))
		n20, err := m.Location.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if m.Properties != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n21, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if m.Inventory != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n22, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	return i, nil
}

func (m *EntityId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntityId) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Id))
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Form != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Form))
	}
	if m.Substance != nil {
		nn23, err := m.Substance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn23
	}
	if m.Properties != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n24, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Inventory != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n25, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	return i, nil
}

func (m *Item_Material) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Material))
	return i, nil
}
func (m *Item_Components_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Components != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Components.Size()))
		n26, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}
func (m *Item_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, msg := range m.Components {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AbsolutePoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbsolutePoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Chunk.Size()))
		n27, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if m.Voxel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Voxel.Size()))
		n28, err := m.Voxel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Y))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Z))
	}
	return i, nil
}

func (m *Actions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	if m.Action != nil {
		nn29, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn29
	}
	return i, nil
}

func (m *Action_Move) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Move != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Move.Size()))
		n30, err := m.Move.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}
func (m *Action_Craft) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Craft != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Craft.Size()))
		n31, err := m.Craft.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	return i, nil
}
func (m *Action_MoveAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_MoveAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WhereTo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WhereTo.Size()))
		n32, err := m.WhereTo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n32
	}
	return i, nil
}

func (m *Action_CraftAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_CraftAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Verb != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectLocation.Size()))
		n33, err := m.ObjectLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n33
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputForms) > 0 {
		dAtA35 := make([]byte, len(m.OutputForms)*10)
		var j34 int
		for _, num := range m.OutputForms {
			for num >= 1<<7 {
				dAtA35[j34] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j34++
			}
			dAtA35[j34] = uint8(num)
			j34++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j34))
		i += copy(dAtA[i:], dAtA35[:j34])
	}
	return i, nil
}

func (m *Content) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Content) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Definitions) > 0 {
		for k, _ := range m.Definitions {
			dAtA[i] = 0xa
			i++
			v := m.Definitions[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n36, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n36
			}
		}
	}
	return i, nil
}

func (m *AllContent) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AllContent) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entity != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Entity.Size()))
		n37, err := m.Entity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n37
	}
	if m.Voxel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Voxel.Size()))
		n38, err := m.Voxel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n38
	}
	if m.Form != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Form.Size()))
		n39, err := m.Form.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n39
	}
	if m.Material != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Material.Size()))
		n40, err := m.Material.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n40
	}
	return i, nil
}

func (m *PrimitiveMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, _ := range m.Map {
			dAtA[i] = 0xa
			i++
			v := m.Map[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n41, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n41
			}
		}
	}
	return i, nil
}

func (m *Primitive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primitive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn42, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn42
	}
	return i, nil
}

func (m *Primitive_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.String_)))
	i += copy(dAtA[i:], m.String_)
	return i, nil
}
func (m *Primitive_Int) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Int))
	return i, nil
}
func (m *Primitive_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Primitive_Float) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x25
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
	i += 4
	return i, nil
}
func (m *Nothing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nothing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Age) Size() (n int) {
	var l int
	_ = l
	if m.Ticks != 0 {
		n += 1 + sovTypes(uint64(m.Ticks))
	}
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Player) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	l = len(m.Address)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.LoggedIn {
		n += 2
	}
	if m.Spawn != nil {
		l = m.Spawn.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Players) Size() (n int) {
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlayerList) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PlayerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PlayerDetails) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		l = 0
		for _, e := range m.Voxels {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Compound) > 0 {
		for k, v := range m.Compound {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Entities) > 0 {
		l = 0
		for _, e := range m.Entities {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Chunk_Compound) Size() (n int) {
	var l int
	_ = l
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MultiblockChunk != nil {
		l = m.MultiblockChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk_ItemAtPoint) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Inventory) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *InventorySlot) Size() (n int) {
	var l int
	_ = l
	if m.ContainerType != 0 {
		n += 1 + sovTypes(uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		n += m.ContainerLocation.Size()
	}
	if len(m.Slots) > 0 {
		l = 0
		for _, e := range m.Slots {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *InventorySlot_Point) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *InventorySlot_EntityId) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.EntityId))
	return n
}
func (m *Entity) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Control != 0 {
		n += 1 + sovTypes(uint64(m.Control))
	}
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *EntityId) Size() (n int) {
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovTypes(uint64(m.Id))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.Form != 0 {
		n += 1 + sovTypes(uint64(m.Form))
	}
	if m.Substance != nil {
		n += m.Substance.Size()
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Item_Material) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Material))
	return n
}
func (m *Item_Components_) Size() (n int) {
	var l int
	_ = l
	if m.Components != nil {
		l = m.Components.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Item_Components) Size() (n int) {
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AbsolutePoint) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Voxel != nil {
		l = m.Voxel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovTypes(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sovTypes(uint64(m.Z))
	}
	return n
}

func (m *Actions) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Action) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Move) Size() (n int) {
	var l int
	_ = l
	if m.Move != nil {
		l = m.Move.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_Craft) Size() (n int) {
	var l int
	_ = l
	if m.Craft != nil {
		l = m.Craft.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_MoveAction) Size() (n int) {
	var l int
	_ = l
	if m.WhereTo != nil {
		l = m.WhereTo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Action_CraftAction) Size() (n int) {
	var l int
	_ = l
	if m.Verb != 0 {
		n += 1 + sovTypes(uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		l = m.ObjectLocation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.OutputForms) > 0 {
		l = 0
		for _, e := range m.OutputForms {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *Content) Size() (n int) {
	var l int
	_ = l
	if len(m.Definitions) > 0 {
		for k, v := range m.Definitions {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *AllContent) Size() (n int) {
	var l int
	_ = l
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Voxel != nil {
		l = m.Voxel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Form != nil {
		l = m.Form.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Material != nil {
		l = m.Material.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *PrimitiveMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Primitive) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Primitive_String_) Size() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Primitive_Int) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Int))
	return n
}
func (m *Primitive_Bool) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Primitive_Float) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *Nothing) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Age) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Age: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Age: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticks", wireType)
			}
			m.Ticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ticks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PrimitiveMap{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = append(m.Address[:0], dAtA[iNdEx:postIndex]...)
			if m.Address == nil {
				m.Address = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoggedIn = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spawn", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Spawn == nil {
				m.Spawn = &AbsolutePoint{}
			}
			if err := m.Spawn.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Players) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Players: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Players: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[string]*Player)
			}
			var mapkey string
			var mapvalue *Player
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Player{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerDetails) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerDetails: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerDetails: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Player == nil {
				m.Player = &Player{}
			}
			if err := m.Player.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &Entity{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Voxels = append(m.Voxels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Voxels = append(m.Voxels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxels", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compound == nil {
				m.Compound = make(map[uint32]*Chunk_Compound)
			}
			var mapkey uint32
			var mapvalue *Chunk_Compound
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Chunk_Compound{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Compound[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (int64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Entities = append(m.Entities, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (int64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Entities = append(m.Entities, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Chunk_ItemAtPoint{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_Compound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Compound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Compound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiblockChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiblockChunk == nil {
				m.MultiblockChunk = &Point{}
			}
			if err := m.MultiblockChunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_ItemAtPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemAtPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemAtPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &Item{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventorySlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventorySlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventorySlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerType", wireType)
			}
			m.ContainerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerType |= (InventorySlot_ContainerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &AbsolutePoint{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.ContainerLocation = &InventorySlot_Point{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntityId", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ContainerLocation = &InventorySlot_EntityId{v}
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Slots = append(m.Slots, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Slots = append(m.Slots, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Control", wireType)
			}
			m.Control = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Control |= (Entity_Control(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &AbsolutePoint{}
			}
			if err := m.Location.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EntityId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Form", wireType)
			}
			m.Form = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Form |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Material", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Substance = &Item_Material{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Item_Components{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Substance = &Item_Components_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &Item{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbsolutePoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbsolutePoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbsolutePoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &Point{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voxel == nil {
				m.Voxel = &Point{}
			}
			if err := m.Voxel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_MoveAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Move{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Craft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_CraftAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Craft{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_MoveAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhereTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WhereTo == nil {
				m.WhereTo = &AbsolutePoint{}
			}
			if err := m.WhereTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_CraftAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CraftAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CraftAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			m.Verb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verb |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectLocation == nil {
				m.ObjectLocation = &AbsolutePoint{}
			}
			if err := m.ObjectLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &InventorySlot{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputForms = append(m.OutputForms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputForms = append(m.OutputForms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputForms", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Content) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Content: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Content: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definitions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definitions == nil {
				m.Definitions = make(map[uint32]*PrimitiveMap)
			}
			var mapkey uint32
			var mapvalue *PrimitiveMap
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &PrimitiveMap{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Definitions[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AllContent) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AllContent: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AllContent: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &Content{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voxel == nil {
				m.Voxel = &Content{}
			}
			if err := m.Voxel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Form", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Form == nil {
				m.Form = &Content{}
			}
			if err := m.Form.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Material", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Material == nil {
				m.Material = &Content{}
			}
			if err := m.Material.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*Primitive)
			}
			var mapkey string
			var mapvalue *Primitive
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Primitive{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primitive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primitive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primitive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Primitive_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Primitive_Int{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Primitive_Bool{b}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Primitive_Float{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nothing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nothing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nothing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1298 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0x4d, 0x6f, 0xdb, 0x46,
	0x13, 0x16, 0x45, 0x91, 0x94, 0x46, 0x96, 0xa3, 0x6c, 0xf2, 0x06, 0x8a, 0xe2, 0x57, 0x55, 0xd9,
	0x24, 0x55, 0xbf, 0x98, 0x44, 0x01, 0x82, 0xa2, 0x3d, 0x59, 0x8a, 0x02, 0x1b, 0xb5, 0x5d, 0x77,
	0x6b, 0x14, 0xcd, 0x91, 0x92, 0xd6, 0x0e, 0x6b, 0x8a, 0x4b, 0x90, 0x2b, 0x25, 0x0a, 0x0a, 0xf4,
	0xd8, 0x9e, 0x0b, 0x04, 0xe8, 0xa1, 0xb7, 0xfe, 0x96, 0x02, 0x3d, 0xf6, 0x27, 0x14, 0xee, 0xa1,
	0xff, 0xa0, 0xe7, 0x62, 0xbf, 0x28, 0x92, 0x31, 0x52, 0xf4, 0x62, 0xef, 0xcc, 0x3c, 0x9a, 0x9d,
	0x7d, 0xf6, 0x99, 0x59, 0xc2, 0x55, 0xb6, 0x8e, 0x49, 0x7a, 0x4f, 0xfc, 0xf5, 0xe2, 0x84, 0x32,
	0xea, 0xde, 0x02, 0x73, 0xf7, 0x8c, 0xa0, 0xeb, 0x60, 0xb1, 0x60, 0x76, 0x9e, 0x76, 0x8c, 0xbe,
	0x31, 0xa8, 0x61, 0x69, 0xb8, 0x0f, 0xc0, 0x1e, 0xd3, 0xe8, 0x34, 0x38, 0x43, 0xef, 0x82, 0x43,
	0x63, 0x16, 0xd0, 0x48, 0x22, 0x9a, 0xc3, 0x96, 0x77, 0x9c, 0x04, 0x8b, 0x80, 0x05, 0x2b, 0x72,
	0xe8, 0xc7, 0x58, 0x47, 0xdd, 0x1f, 0x0c, 0xb0, 0x8f, 0x43, 0x7f, 0x4d, 0x12, 0xb4, 0x0d, 0xd5,
	0x60, 0x2e, 0xe0, 0x26, 0xae, 0x06, 0x73, 0xd4, 0x01, 0xc7, 0x9f, 0xcf, 0x13, 0x92, 0xa6, 0x9d,
	0x6a, 0xdf, 0x18, 0x6c, 0x61, 0x6d, 0x22, 0x04, 0xb5, 0xc8, 0x5f, 0x90, 0x8e, 0xd9, 0x37, 0x06,
	0x0d, 0x2c, 0xd6, 0xa8, 0x0b, 0xf5, 0x90, 0x9e, 0x9d, 0x91, 0xf9, 0x7e, 0xd4, 0xa9, 0xf5, 0x8d,
	0x41, 0x1d, 0x67, 0x36, 0xba, 0x0d, 0x56, 0x1a, 0xfb, 0xcf, 0xa3, 0x8e, 0x25, 0x6a, 0xd9, 0xf6,
	0x76, 0xa7, 0x29, 0x0d, 0x97, 0x8c, 0x1c, 0xd3, 0x20, 0x62, 0x58, 0x06, 0xdd, 0xef, 0xc0, 0x91,
	0x95, 0xa4, 0xe8, 0x1e, 0x38, 0xb1, 0x5c, 0x76, 0x8c, 0xbe, 0x39, 0x68, 0x0e, 0xff, 0xe7, 0xa9,
	0x90, 0xfe, 0x3f, 0x89, 0x58, 0xb2, 0xc6, 0x1a, 0xd5, 0x1d, 0xc3, 0x56, 0x3e, 0x80, 0xda, 0x60,
	0x9e, 0x93, 0xb5, 0x38, 0x4c, 0x03, 0xf3, 0x25, 0xfa, 0x3f, 0x58, 0x2b, 0x3f, 0x5c, 0x12, 0x71,
	0x96, 0xe6, 0xd0, 0x51, 0x89, 0xb0, 0xf4, 0x7e, 0x52, 0xfd, 0xd8, 0x70, 0x5d, 0x00, 0xe9, 0x3c,
	0x08, 0x52, 0xc6, 0x29, 0xe6, 0x07, 0x93, 0x15, 0x34, 0xb0, 0x34, 0xdc, 0xbe, 0xc6, 0x1c, 0xf1,
	0x43, 0x6b, 0x22, 0x8c, 0x0d, 0x11, 0xee, 0x17, 0xd0, 0x92, 0x88, 0xc7, 0x84, 0xf9, 0x41, 0x98,
	0xa2, 0xb7, 0xc0, 0x96, 0x65, 0xaa, 0xab, 0xc8, 0xb6, 0x56, 0x6e, 0x0e, 0x20, 0x11, 0x0b, 0xd8,
	0x3a, 0xab, 0x6d, 0x22, 0x4c, 0xac, 0xdc, 0xee, 0xaf, 0x26, 0x58, 0xe3, 0x67, 0xcb, 0xe8, 0x1c,
	0xdd, 0x00, 0x7b, 0x45, 0x5f, 0x90, 0x50, 0x56, 0x55, 0xc3, 0xca, 0x42, 0xf7, 0xa1, 0x3e, 0xa3,
	0x8b, 0x98, 0x2e, 0xa3, 0x79, 0xa7, 0x2a, 0x18, 0xbb, 0xee, 0x89, 0x5f, 0x78, 0x63, 0xe5, 0x96,
	0x84, 0x65, 0x28, 0x7e, 0x5f, 0x22, 0x7b, 0x40, 0xd2, 0x8e, 0xd9, 0x37, 0x07, 0x26, 0xce, 0x6c,
	0x34, 0x00, 0x2b, 0x60, 0x64, 0x91, 0x76, 0x6a, 0x22, 0x15, 0x52, 0xa9, 0xf6, 0x19, 0x59, 0xec,
	0x32, 0x75, 0x67, 0x02, 0xd0, 0x7d, 0x65, 0x40, 0x5d, 0xef, 0x80, 0x06, 0xd0, 0x08, 0xa2, 0x15,
	0x89, 0x18, 0x4d, 0xd6, 0xea, 0xac, 0xe0, 0xed, 0x6b, 0x0f, 0xde, 0x04, 0xd1, 0x47, 0x00, 0x71,
	0x42, 0x63, 0x92, 0x88, 0xed, 0xab, 0x97, 0x29, 0x34, 0x07, 0x40, 0xf7, 0xe1, 0xca, 0x62, 0x19,
	0xb2, 0x60, 0x1a, 0xd2, 0xd9, 0xb9, 0xa8, 0x45, 0x48, 0xaf, 0x39, 0xb4, 0x3d, 0x59, 0x4d, 0x39,
	0xdc, 0x3d, 0x80, 0x56, 0xe1, 0xe0, 0x79, 0x41, 0xb4, 0xa4, 0x20, 0xee, 0x14, 0x05, 0x71, 0xa5,
	0xc4, 0x57, 0x4e, 0x18, 0xdd, 0x27, 0xd0, 0xcc, 0x9d, 0x1d, 0xed, 0x80, 0x15, 0xf3, 0x85, 0x3a,
	0xa3, 0x2e, 0x42, 0x3a, 0xd1, 0x4d, 0xa8, 0x71, 0x6e, 0x54, 0x5a, 0x4b, 0xb0, 0x86, 0x85, 0xcb,
	0x1d, 0x40, 0x23, 0xa3, 0x03, 0xdd, 0xd2, 0x24, 0x4b, 0x85, 0x2b, 0xa0, 0xf4, 0xb9, 0x7f, 0x1b,
	0xd0, 0xca, 0xa0, 0x5f, 0x86, 0x94, 0xa1, 0x11, 0xb4, 0x66, 0x34, 0x62, 0x7e, 0x10, 0x91, 0xe4,
	0x64, 0x1d, 0x4b, 0xcd, 0x6d, 0x0f, 0x77, 0xbc, 0x02, 0xcc, 0x1b, 0xe7, 0x31, 0xb8, 0xf8, 0x13,
	0x74, 0x57, 0x17, 0x5e, 0xbd, 0xac, 0x0f, 0xf7, 0x2a, 0xfa, 0x08, 0x3b, 0x4a, 0x1b, 0xeb, 0xfd,
	0xb9, 0x20, 0xda, 0xdc, 0xab, 0xe0, 0xcc, 0xc3, 0x1b, 0x23, 0x0d, 0x29, 0x93, 0xea, 0x68, 0x61,
	0x69, 0xb8, 0xf7, 0x39, 0xe3, 0xf9, 0xcd, 0x1a, 0x60, 0x7d, 0xf5, 0xf9, 0xd7, 0x93, 0x83, 0x76,
	0x05, 0x01, 0xd8, 0x93, 0xa3, 0x93, 0xfd, 0x93, 0xa7, 0x6d, 0x03, 0xd5, 0xa1, 0xb6, 0x7f, 0x32,
	0x39, 0x6c, 0x57, 0x47, 0xd7, 0xe0, 0x6a, 0x56, 0xde, 0x01, 0x9d, 0xf9, 0x7c, 0x20, 0xb9, 0x3f,
	0x57, 0xc1, 0x96, 0xea, 0x7f, 0x6d, 0x1e, 0x21, 0xa8, 0xf1, 0x49, 0x28, 0x8a, 0x6f, 0x61, 0xb1,
	0x46, 0xef, 0x81, 0xc3, 0x73, 0x24, 0x34, 0x14, 0x85, 0x6e, 0x0f, 0xaf, 0xa8, 0xde, 0x11, 0x44,
	0x24, 0x34, 0xc4, 0x3a, 0x8e, 0xde, 0xe7, 0x03, 0x4a, 0xee, 0x22, 0x06, 0xd4, 0xeb, 0x73, 0x28,
	0x8b, 0x97, 0xf4, 0x69, 0xfd, 0x9b, 0x3e, 0x0b, 0xc2, 0xb7, 0xdf, 0x24, 0xfc, 0x1e, 0x40, 0x9c,
	0x8d, 0x8f, 0x8e, 0x23, 0xc6, 0x46, 0xce, 0xe3, 0xf6, 0xc0, 0x51, 0x85, 0x73, 0xd2, 0x8e, 0x0f,
	0x76, 0x9f, 0x4e, 0x70, 0xbb, 0x82, 0x1c, 0x30, 0x8f, 0x8e, 0xc7, 0x6d, 0xc3, 0xed, 0x42, 0x7d,
	0xa2, 0xef, 0xa1, 0xc4, 0x8f, 0xfb, 0x7d, 0x15, 0x6a, 0x5c, 0x43, 0x9c, 0xa8, 0x53, 0x9a, 0x2c,
	0x94, 0xd8, 0xc5, 0x9a, 0x5f, 0xe9, 0xc2, 0x67, 0x24, 0x09, 0xfc, 0x50, 0x12, 0xc8, 0xaf, 0x54,
	0x7b, 0xd0, 0x10, 0x40, 0x0c, 0x86, 0x88, 0x44, 0x2c, 0x55, 0xbd, 0xd5, 0x16, 0x82, 0x94, 0xfd,
	0x20, 0xfc, 0x7b, 0x15, 0x9c, 0x43, 0x95, 0x38, 0xaa, 0xfd, 0x27, 0x8e, 0xac, 0x37, 0x70, 0xd4,
	0x7d, 0x08, 0xb0, 0xd9, 0x14, 0xdd, 0x29, 0x94, 0x56, 0xe8, 0x95, 0x5c, 0x60, 0xd4, 0x84, 0x46,
	0xba, 0x9c, 0xa6, 0xcc, 0x8f, 0x66, 0xc4, 0xfd, 0x0c, 0x5a, 0x85, 0x9b, 0xe5, 0x1d, 0x3b, 0x13,
	0x63, 0xa3, 0xd4, 0xb1, 0xc2, 0xc9, 0xa3, 0x62, 0x8c, 0xaa, 0xb6, 0xc8, 0xa2, 0xc2, 0xe9, 0x3e,
	0x00, 0x4b, 0x26, 0xd9, 0x02, 0xe3, 0x85, 0xa2, 0xdb, 0x78, 0xc1, 0x2d, 0x39, 0xaf, 0x4d, 0x6c,
	0xac, 0xb9, 0xf5, 0x52, 0xb6, 0x0a, 0x36, 0x5e, 0xba, 0x1f, 0x82, 0xb3, 0x3b, 0x13, 0xef, 0x2b,
	0x7a, 0x1b, 0x1c, 0x7f, 0xa6, 0x1f, 0x62, 0x53, 0x0c, 0x77, 0x19, 0xc2, 0xda, 0xef, 0xfe, 0x55,
	0x05, 0x5b, 0xfa, 0x4a, 0xf2, 0x30, 0xca, 0xf2, 0x40, 0x03, 0xa8, 0x2d, 0xe8, 0x4a, 0x8f, 0x2c,
	0xa4, 0x52, 0x79, 0x87, 0x74, 0x45, 0xe4, 0x72, 0xaf, 0x82, 0x05, 0x02, 0x7d, 0x00, 0xd6, 0x2c,
	0xf1, 0x4f, 0x99, 0xba, 0xcc, 0x6b, 0x1a, 0x3a, 0xe6, 0xce, 0x0c, 0x2b, 0x31, 0xdd, 0x47, 0x00,
	0x9b, 0x14, 0x68, 0x00, 0xce, 0xf3, 0x67, 0x24, 0x21, 0x27, 0x54, 0xd1, 0x55, 0xee, 0x13, 0x1d,
	0xee, 0xfe, 0x62, 0x40, 0x33, 0x97, 0x90, 0x0b, 0x6f, 0x45, 0x92, 0xa9, 0x16, 0x1e, 0x5f, 0xa3,
	0x47, 0xb0, 0x4d, 0xa7, 0xdf, 0x90, 0x19, 0xd3, 0x2d, 0x7e, 0xf9, 0xf0, 0xc1, 0x25, 0x14, 0xba,
	0x0b, 0x76, 0x10, 0xc5, 0x4b, 0x26, 0x5f, 0x27, 0x8e, 0x2f, 0x0c, 0x3a, 0xac, 0xa2, 0xa8, 0x0f,
	0x4d, 0xba, 0x64, 0xf1, 0x92, 0x3d, 0xa1, 0xc9, 0x42, 0xcf, 0xa4, 0xbc, 0x6b, 0x54, 0x07, 0x5b,
	0x52, 0xed, 0xbe, 0x32, 0x64, 0x7b, 0x91, 0x88, 0xa1, 0x4f, 0xa1, 0x39, 0x27, 0xa7, 0x41, 0x14,
	0xe4, 0x2f, 0xe7, 0xa6, 0xa7, 0xc2, 0xde, 0xe3, 0x4d, 0x4c, 0xbe, 0x9c, 0x79, 0x74, 0xf7, 0x10,
	0xda, 0x65, 0xc0, 0x25, 0x2f, 0xcc, 0x3b, 0xc5, 0x17, 0xa6, 0xd4, 0x1c, 0xb9, 0x0f, 0x8f, 0x1f,
	0x0d, 0x80, 0xdd, 0x30, 0xd4, 0xa5, 0xf5, 0xb3, 0xef, 0x01, 0xc9, 0x7f, 0x5d, 0x57, 0xa5, 0x3f,
	0x08, 0x50, 0xaf, 0xa8, 0xd8, 0x0d, 0x40, 0xba, 0xd1, 0x8e, 0x9a, 0x00, 0x66, 0x29, 0x2c, 0x67,
	0xc1, 0xed, 0xdc, 0x2c, 0xa8, 0x95, 0x10, 0x59, 0xc4, 0xfd, 0x16, 0xb6, 0xf2, 0xf5, 0xa2, 0x01,
	0x98, 0x0b, 0x3f, 0x56, 0x44, 0xdd, 0x28, 0x9c, 0xc5, 0x3b, 0xf4, 0x63, 0xc9, 0x12, 0x87, 0x74,
	0x47, 0x50, 0xd7, 0x8e, 0x4b, 0x3e, 0xc4, 0xfa, 0x45, 0x56, 0x60, 0x93, 0x29, 0x4f, 0x49, 0x0c,
	0x8d, 0xcc, 0x8f, 0x3a, 0x60, 0xa7, 0x2c, 0x09, 0xa2, 0x33, 0x99, 0x67, 0xaf, 0x82, 0x95, 0x8d,
	0x10, 0x98, 0xfa, 0x3d, 0xe3, 0x8f, 0x14, 0x37, 0xd0, 0x75, 0xa8, 0x4d, 0xa9, 0x7a, 0x10, 0xea,
	0xbc, 0x21, 0xb8, 0x85, 0x6e, 0x80, 0x75, 0x1a, 0x52, 0x9f, 0x89, 0x13, 0x57, 0xb9, 0xf6, 0x85,
	0x39, 0x72, 0x54, 0x39, 0x6e, 0x03, 0x9c, 0x23, 0xca, 0x9e, 0x05, 0xd1, 0xd9, 0xa8, 0xfd, 0xdb,
	0x45, 0xcf, 0xf8, 0xfd, 0xa2, 0x67, 0xfc, 0x71, 0xd1, 0x33, 0x7e, 0xfa, 0xb3, 0x57, 0x99, 0xda,
	0xe2, 0xeb, 0xfb, 0xe1, 0x3f, 0x01, 0x00, 0x00, 0xff, 0xff, 0x95, 0x1b, 0x8a, 0x69, 0x92, 0x0b,
	0x00, 0x00,
}
