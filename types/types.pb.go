// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: types/types.proto

/*
	Package types is a generated protocol buffer package.

	It is generated from these files:
		types/types.proto

	It has these top-level messages:
		Age
		Config
		Players
		PlayerList
		PlayerName
		Chunk
		Inventory
		InventorySlot
		Entity
		Item
		AbsolutePoint
		Point
		Actions
		Action
		PrimitiveMap
		Primitive
		Nothing
*/
package types

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import binary "encoding/binary"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type InventorySlot_ContainerType int32

const (
	InventorySlot_VOXEL  InventorySlot_ContainerType = 0
	InventorySlot_ENTITY InventorySlot_ContainerType = 1
	InventorySlot_ITEM   InventorySlot_ContainerType = 2
)

var InventorySlot_ContainerType_name = map[int32]string{
	0: "VOXEL",
	1: "ENTITY",
	2: "ITEM",
}
var InventorySlot_ContainerType_value = map[string]int32{
	"VOXEL":  0,
	"ENTITY": 1,
	"ITEM":   2,
}

func (x InventorySlot_ContainerType) String() string {
	return proto.EnumName(InventorySlot_ContainerType_name, int32(x))
}
func (InventorySlot_ContainerType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorTypes, []int{7, 0}
}

type Age struct {
	Ticks uint64 `protobuf:"varint,1,opt,name=ticks,proto3" json:"ticks,omitempty"`
}

func (m *Age) Reset()                    { *m = Age{} }
func (m *Age) String() string            { return proto.CompactTextString(m) }
func (*Age) ProtoMessage()               {}
func (*Age) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{0} }

func (m *Age) GetTicks() uint64 {
	if m != nil {
		return m.Ticks
	}
	return 0
}

type Config struct {
	Options *PrimitiveMap `protobuf:"bytes,1,opt,name=options" json:"options,omitempty"`
}

func (m *Config) Reset()                    { *m = Config{} }
func (m *Config) String() string            { return proto.CompactTextString(m) }
func (*Config) ProtoMessage()               {}
func (*Config) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{1} }

func (m *Config) GetOptions() *PrimitiveMap {
	if m != nil {
		return m.Options
	}
	return nil
}

type Players struct {
	Players map[string]*AbsolutePoint `protobuf:"bytes,1,rep,name=players" json:"players,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Players) Reset()                    { *m = Players{} }
func (m *Players) String() string            { return proto.CompactTextString(m) }
func (*Players) ProtoMessage()               {}
func (*Players) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{2} }

func (m *Players) GetPlayers() map[string]*AbsolutePoint {
	if m != nil {
		return m.Players
	}
	return nil
}

type PlayerList struct {
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *PlayerList) Reset()                    { *m = PlayerList{} }
func (m *PlayerList) String() string            { return proto.CompactTextString(m) }
func (*PlayerList) ProtoMessage()               {}
func (*PlayerList) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{3} }

func (m *PlayerList) GetNames() []string {
	if m != nil {
		return m.Names
	}
	return nil
}

type PlayerName struct {
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
}

func (m *PlayerName) Reset()                    { *m = PlayerName{} }
func (m *PlayerName) String() string            { return proto.CompactTextString(m) }
func (*PlayerName) ProtoMessage()               {}
func (*PlayerName) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{4} }

func (m *PlayerName) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

type Chunk struct {
	Voxels   []uint64                   `protobuf:"varint,1,rep,packed,name=voxels" json:"voxels,omitempty"`
	Compound map[uint32]*Chunk_Compound `protobuf:"bytes,2,rep,name=compound" json:"compound,omitempty" protobuf_key:"varint,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	Entities []*Chunk_EntityAtPoint     `protobuf:"bytes,3,rep,name=entities" json:"entities,omitempty"`
	Items    []*Chunk_ItemAtPoint       `protobuf:"bytes,4,rep,name=items" json:"items,omitempty"`
}

func (m *Chunk) Reset()                    { *m = Chunk{} }
func (m *Chunk) String() string            { return proto.CompactTextString(m) }
func (*Chunk) ProtoMessage()               {}
func (*Chunk) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5} }

func (m *Chunk) GetVoxels() []uint64 {
	if m != nil {
		return m.Voxels
	}
	return nil
}

func (m *Chunk) GetCompound() map[uint32]*Chunk_Compound {
	if m != nil {
		return m.Compound
	}
	return nil
}

func (m *Chunk) GetEntities() []*Chunk_EntityAtPoint {
	if m != nil {
		return m.Entities
	}
	return nil
}

func (m *Chunk) GetItems() []*Chunk_ItemAtPoint {
	if m != nil {
		return m.Items
	}
	return nil
}

type Chunk_Compound struct {
	Inventory       *Inventory    `protobuf:"bytes,1,opt,name=inventory" json:"inventory,omitempty"`
	Properties      *PrimitiveMap `protobuf:"bytes,2,opt,name=properties" json:"properties,omitempty"`
	MultiblockChunk *Point        `protobuf:"bytes,3,opt,name=multiblockChunk" json:"multiblockChunk,omitempty"`
}

func (m *Chunk_Compound) Reset()                    { *m = Chunk_Compound{} }
func (m *Chunk_Compound) String() string            { return proto.CompactTextString(m) }
func (*Chunk_Compound) ProtoMessage()               {}
func (*Chunk_Compound) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5, 0} }

func (m *Chunk_Compound) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

func (m *Chunk_Compound) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Chunk_Compound) GetMultiblockChunk() *Point {
	if m != nil {
		return m.MultiblockChunk
	}
	return nil
}

type Chunk_EntityAtPoint struct {
	Point  *Point  `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Entity *Entity `protobuf:"bytes,2,opt,name=entity" json:"entity,omitempty"`
}

func (m *Chunk_EntityAtPoint) Reset()                    { *m = Chunk_EntityAtPoint{} }
func (m *Chunk_EntityAtPoint) String() string            { return proto.CompactTextString(m) }
func (*Chunk_EntityAtPoint) ProtoMessage()               {}
func (*Chunk_EntityAtPoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5, 2} }

func (m *Chunk_EntityAtPoint) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *Chunk_EntityAtPoint) GetEntity() *Entity {
	if m != nil {
		return m.Entity
	}
	return nil
}

type Chunk_ItemAtPoint struct {
	Point *Point `protobuf:"bytes,1,opt,name=point" json:"point,omitempty"`
	Item  *Item  `protobuf:"bytes,2,opt,name=item" json:"item,omitempty"`
}

func (m *Chunk_ItemAtPoint) Reset()                    { *m = Chunk_ItemAtPoint{} }
func (m *Chunk_ItemAtPoint) String() string            { return proto.CompactTextString(m) }
func (*Chunk_ItemAtPoint) ProtoMessage()               {}
func (*Chunk_ItemAtPoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{5, 3} }

func (m *Chunk_ItemAtPoint) GetPoint() *Point {
	if m != nil {
		return m.Point
	}
	return nil
}

func (m *Chunk_ItemAtPoint) GetItem() *Item {
	if m != nil {
		return m.Item
	}
	return nil
}

type Inventory struct {
	Items []*Item `protobuf:"bytes,1,rep,name=items" json:"items,omitempty"`
}

func (m *Inventory) Reset()                    { *m = Inventory{} }
func (m *Inventory) String() string            { return proto.CompactTextString(m) }
func (*Inventory) ProtoMessage()               {}
func (*Inventory) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{6} }

func (m *Inventory) GetItems() []*Item {
	if m != nil {
		return m.Items
	}
	return nil
}

type InventorySlot struct {
	ContainerType     InventorySlot_ContainerType `protobuf:"varint,1,opt,name=containerType,proto3,enum=InventorySlot_ContainerType" json:"containerType,omitempty"`
	ContainerLocation *AbsolutePoint              `protobuf:"bytes,2,opt,name=containerLocation" json:"containerLocation,omitempty"`
	Slots             []uint32                    `protobuf:"varint,3,rep,packed,name=slots" json:"slots,omitempty"`
}

func (m *InventorySlot) Reset()                    { *m = InventorySlot{} }
func (m *InventorySlot) String() string            { return proto.CompactTextString(m) }
func (*InventorySlot) ProtoMessage()               {}
func (*InventorySlot) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{7} }

func (m *InventorySlot) GetContainerType() InventorySlot_ContainerType {
	if m != nil {
		return m.ContainerType
	}
	return InventorySlot_VOXEL
}

func (m *InventorySlot) GetContainerLocation() *AbsolutePoint {
	if m != nil {
		return m.ContainerLocation
	}
	return nil
}

func (m *InventorySlot) GetSlots() []uint32 {
	if m != nil {
		return m.Slots
	}
	return nil
}

type Entity struct {
	// Types that are valid to be assigned to Control:
	//	*Entity_Player_
	//	*Entity_Npc
	Control    isEntity_Control `protobuf_oneof:"control"`
	Type       uint32           `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Properties *PrimitiveMap    `protobuf:"bytes,4,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory       `protobuf:"bytes,5,opt,name=inventory" json:"inventory,omitempty"`
}

func (m *Entity) Reset()                    { *m = Entity{} }
func (m *Entity) String() string            { return proto.CompactTextString(m) }
func (*Entity) ProtoMessage()               {}
func (*Entity) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8} }

type isEntity_Control interface {
	isEntity_Control()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Entity_Player_ struct {
	Player *Entity_Player `protobuf:"bytes,1,opt,name=player,oneof"`
}
type Entity_Npc struct {
	Npc *Entity_NPC `protobuf:"bytes,2,opt,name=npc,oneof"`
}

func (*Entity_Player_) isEntity_Control() {}
func (*Entity_Npc) isEntity_Control()     {}

func (m *Entity) GetControl() isEntity_Control {
	if m != nil {
		return m.Control
	}
	return nil
}

func (m *Entity) GetPlayer() *Entity_Player {
	if x, ok := m.GetControl().(*Entity_Player_); ok {
		return x.Player
	}
	return nil
}

func (m *Entity) GetNpc() *Entity_NPC {
	if x, ok := m.GetControl().(*Entity_Npc); ok {
		return x.Npc
	}
	return nil
}

func (m *Entity) GetType() uint32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *Entity) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Entity) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Entity) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Entity_OneofMarshaler, _Entity_OneofUnmarshaler, _Entity_OneofSizer, []interface{}{
		(*Entity_Player_)(nil),
		(*Entity_Npc)(nil),
	}
}

func _Entity_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Entity)
	// control
	switch x := m.Control.(type) {
	case *Entity_Player_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Player); err != nil {
			return err
		}
	case *Entity_Npc:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Npc); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Entity.Control has unexpected type %T", x)
	}
	return nil
}

func _Entity_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Entity)
	switch tag {
	case 1: // control.player
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Entity_Player)
		err := b.DecodeMessage(msg)
		m.Control = &Entity_Player_{msg}
		return true, err
	case 2: // control.npc
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Entity_NPC)
		err := b.DecodeMessage(msg)
		m.Control = &Entity_Npc{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Entity_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Entity)
	// control
	switch x := m.Control.(type) {
	case *Entity_Player_:
		s := proto.Size(x.Player)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Entity_Npc:
		s := proto.Size(x.Npc)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Entity_Player struct {
	LoggedIn bool `protobuf:"varint,1,opt,name=loggedIn,proto3" json:"loggedIn,omitempty"`
}

func (m *Entity_Player) Reset()                    { *m = Entity_Player{} }
func (m *Entity_Player) String() string            { return proto.CompactTextString(m) }
func (*Entity_Player) ProtoMessage()               {}
func (*Entity_Player) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8, 0} }

func (m *Entity_Player) GetLoggedIn() bool {
	if m != nil {
		return m.LoggedIn
	}
	return false
}

type Entity_NPC struct {
	Algorithm uint32 `protobuf:"varint,1,opt,name=Algorithm,proto3" json:"Algorithm,omitempty"`
}

func (m *Entity_NPC) Reset()                    { *m = Entity_NPC{} }
func (m *Entity_NPC) String() string            { return proto.CompactTextString(m) }
func (*Entity_NPC) ProtoMessage()               {}
func (*Entity_NPC) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{8, 1} }

func (m *Entity_NPC) GetAlgorithm() uint32 {
	if m != nil {
		return m.Algorithm
	}
	return 0
}

type Item struct {
	Form uint32 `protobuf:"varint,1,opt,name=form,proto3" json:"form,omitempty"`
	// Types that are valid to be assigned to Substance:
	//	*Item_Material
	//	*Item_Components_
	Substance  isItem_Substance `protobuf_oneof:"substance"`
	Properties *PrimitiveMap    `protobuf:"bytes,4,opt,name=properties" json:"properties,omitempty"`
	Inventory  *Inventory       `protobuf:"bytes,5,opt,name=inventory" json:"inventory,omitempty"`
}

func (m *Item) Reset()                    { *m = Item{} }
func (m *Item) String() string            { return proto.CompactTextString(m) }
func (*Item) ProtoMessage()               {}
func (*Item) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9} }

type isItem_Substance interface {
	isItem_Substance()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Item_Material struct {
	Material uint32 `protobuf:"varint,2,opt,name=material,proto3,oneof"`
}
type Item_Components_ struct {
	Components *Item_Components `protobuf:"bytes,3,opt,name=components,oneof"`
}

func (*Item_Material) isItem_Substance()    {}
func (*Item_Components_) isItem_Substance() {}

func (m *Item) GetSubstance() isItem_Substance {
	if m != nil {
		return m.Substance
	}
	return nil
}

func (m *Item) GetForm() uint32 {
	if m != nil {
		return m.Form
	}
	return 0
}

func (m *Item) GetMaterial() uint32 {
	if x, ok := m.GetSubstance().(*Item_Material); ok {
		return x.Material
	}
	return 0
}

func (m *Item) GetComponents() *Item_Components {
	if x, ok := m.GetSubstance().(*Item_Components_); ok {
		return x.Components
	}
	return nil
}

func (m *Item) GetProperties() *PrimitiveMap {
	if m != nil {
		return m.Properties
	}
	return nil
}

func (m *Item) GetInventory() *Inventory {
	if m != nil {
		return m.Inventory
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Item) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Item_OneofMarshaler, _Item_OneofUnmarshaler, _Item_OneofSizer, []interface{}{
		(*Item_Material)(nil),
		(*Item_Components_)(nil),
	}
}

func _Item_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Material))
	case *Item_Components_:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Components); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Item.Substance has unexpected type %T", x)
	}
	return nil
}

func _Item_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Item)
	switch tag {
	case 2: // substance.material
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Substance = &Item_Material{uint32(x)}
		return true, err
	case 3: // substance.components
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Item_Components)
		err := b.DecodeMessage(msg)
		m.Substance = &Item_Components_{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Item_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Item)
	// substance
	switch x := m.Substance.(type) {
	case *Item_Material:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Material))
	case *Item_Components_:
		s := proto.Size(x.Components)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Item_Components struct {
	Components []*Item `protobuf:"bytes,1,rep,name=components" json:"components,omitempty"`
}

func (m *Item_Components) Reset()                    { *m = Item_Components{} }
func (m *Item_Components) String() string            { return proto.CompactTextString(m) }
func (*Item_Components) ProtoMessage()               {}
func (*Item_Components) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{9, 0} }

func (m *Item_Components) GetComponents() []*Item {
	if m != nil {
		return m.Components
	}
	return nil
}

type AbsolutePoint struct {
	Chunk *Point `protobuf:"bytes,1,opt,name=chunk" json:"chunk,omitempty"`
	Voxel *Point `protobuf:"bytes,2,opt,name=voxel" json:"voxel,omitempty"`
}

func (m *AbsolutePoint) Reset()                    { *m = AbsolutePoint{} }
func (m *AbsolutePoint) String() string            { return proto.CompactTextString(m) }
func (*AbsolutePoint) ProtoMessage()               {}
func (*AbsolutePoint) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{10} }

func (m *AbsolutePoint) GetChunk() *Point {
	if m != nil {
		return m.Chunk
	}
	return nil
}

func (m *AbsolutePoint) GetVoxel() *Point {
	if m != nil {
		return m.Voxel
	}
	return nil
}

type Point struct {
	X int64 `protobuf:"varint,1,opt,name=x,proto3" json:"x,omitempty"`
	Y int64 `protobuf:"varint,2,opt,name=y,proto3" json:"y,omitempty"`
	Z int64 `protobuf:"varint,3,opt,name=z,proto3" json:"z,omitempty"`
}

func (m *Point) Reset()                    { *m = Point{} }
func (m *Point) String() string            { return proto.CompactTextString(m) }
func (*Point) ProtoMessage()               {}
func (*Point) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{11} }

func (m *Point) GetX() int64 {
	if m != nil {
		return m.X
	}
	return 0
}

func (m *Point) GetY() int64 {
	if m != nil {
		return m.Y
	}
	return 0
}

func (m *Point) GetZ() int64 {
	if m != nil {
		return m.Z
	}
	return 0
}

type Actions struct {
	Actions []*Action `protobuf:"bytes,1,rep,name=actions" json:"actions,omitempty"`
}

func (m *Actions) Reset()                    { *m = Actions{} }
func (m *Actions) String() string            { return proto.CompactTextString(m) }
func (*Actions) ProtoMessage()               {}
func (*Actions) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{12} }

func (m *Actions) GetActions() []*Action {
	if m != nil {
		return m.Actions
	}
	return nil
}

type Action struct {
	PlayerName string `protobuf:"bytes,1,opt,name=playerName,proto3" json:"playerName,omitempty"`
	// Types that are valid to be assigned to Action:
	//	*Action_Move
	//	*Action_Craft
	Action isAction_Action `protobuf_oneof:"action"`
}

func (m *Action) Reset()                    { *m = Action{} }
func (m *Action) String() string            { return proto.CompactTextString(m) }
func (*Action) ProtoMessage()               {}
func (*Action) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13} }

type isAction_Action interface {
	isAction_Action()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Action_Move struct {
	Move *Action_MoveAction `protobuf:"bytes,2,opt,name=move,oneof"`
}
type Action_Craft struct {
	Craft *Action_CraftAction `protobuf:"bytes,3,opt,name=craft,oneof"`
}

func (*Action_Move) isAction_Action()  {}
func (*Action_Craft) isAction_Action() {}

func (m *Action) GetAction() isAction_Action {
	if m != nil {
		return m.Action
	}
	return nil
}

func (m *Action) GetPlayerName() string {
	if m != nil {
		return m.PlayerName
	}
	return ""
}

func (m *Action) GetMove() *Action_MoveAction {
	if x, ok := m.GetAction().(*Action_Move); ok {
		return x.Move
	}
	return nil
}

func (m *Action) GetCraft() *Action_CraftAction {
	if x, ok := m.GetAction().(*Action_Craft); ok {
		return x.Craft
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Action) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Action_OneofMarshaler, _Action_OneofUnmarshaler, _Action_OneofSizer, []interface{}{
		(*Action_Move)(nil),
		(*Action_Craft)(nil),
	}
}

func _Action_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		_ = b.EncodeVarint(2<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Move); err != nil {
			return err
		}
	case *Action_Craft:
		_ = b.EncodeVarint(3<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Craft); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("Action.Action has unexpected type %T", x)
	}
	return nil
}

func _Action_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Action)
	switch tag {
	case 2: // action.move
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_MoveAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Move{msg}
		return true, err
	case 3: // action.craft
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Action_CraftAction)
		err := b.DecodeMessage(msg)
		m.Action = &Action_Craft{msg}
		return true, err
	default:
		return false, nil
	}
}

func _Action_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Action)
	// action
	switch x := m.Action.(type) {
	case *Action_Move:
		s := proto.Size(x.Move)
		n += proto.SizeVarint(2<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case *Action_Craft:
		s := proto.Size(x.Craft)
		n += proto.SizeVarint(3<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Action_MoveAction struct {
	WhereTo *AbsolutePoint `protobuf:"bytes,1,opt,name=whereTo" json:"whereTo,omitempty"`
}

func (m *Action_MoveAction) Reset()                    { *m = Action_MoveAction{} }
func (m *Action_MoveAction) String() string            { return proto.CompactTextString(m) }
func (*Action_MoveAction) ProtoMessage()               {}
func (*Action_MoveAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13, 0} }

func (m *Action_MoveAction) GetWhereTo() *AbsolutePoint {
	if m != nil {
		return m.WhereTo
	}
	return nil
}

type Action_CraftAction struct {
	Verb           uint32           `protobuf:"varint,1,opt,name=verb,proto3" json:"verb,omitempty"`
	ObjectLocation *AbsolutePoint   `protobuf:"bytes,2,opt,name=objectLocation" json:"objectLocation,omitempty"`
	Inputs         []*InventorySlot `protobuf:"bytes,3,rep,name=inputs" json:"inputs,omitempty"`
	OutputForms    []uint32         `protobuf:"varint,4,rep,packed,name=outputForms" json:"outputForms,omitempty"`
}

func (m *Action_CraftAction) Reset()                    { *m = Action_CraftAction{} }
func (m *Action_CraftAction) String() string            { return proto.CompactTextString(m) }
func (*Action_CraftAction) ProtoMessage()               {}
func (*Action_CraftAction) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{13, 1} }

func (m *Action_CraftAction) GetVerb() uint32 {
	if m != nil {
		return m.Verb
	}
	return 0
}

func (m *Action_CraftAction) GetObjectLocation() *AbsolutePoint {
	if m != nil {
		return m.ObjectLocation
	}
	return nil
}

func (m *Action_CraftAction) GetInputs() []*InventorySlot {
	if m != nil {
		return m.Inputs
	}
	return nil
}

func (m *Action_CraftAction) GetOutputForms() []uint32 {
	if m != nil {
		return m.OutputForms
	}
	return nil
}

type PrimitiveMap struct {
	Map map[string]*Primitive `protobuf:"bytes,1,rep,name=map" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *PrimitiveMap) Reset()                    { *m = PrimitiveMap{} }
func (m *PrimitiveMap) String() string            { return proto.CompactTextString(m) }
func (*PrimitiveMap) ProtoMessage()               {}
func (*PrimitiveMap) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{14} }

func (m *PrimitiveMap) GetMap() map[string]*Primitive {
	if m != nil {
		return m.Map
	}
	return nil
}

type Primitive struct {
	// Types that are valid to be assigned to Value:
	//	*Primitive_String_
	//	*Primitive_Int
	//	*Primitive_Bool
	//	*Primitive_Float
	Value isPrimitive_Value `protobuf_oneof:"value"`
}

func (m *Primitive) Reset()                    { *m = Primitive{} }
func (m *Primitive) String() string            { return proto.CompactTextString(m) }
func (*Primitive) ProtoMessage()               {}
func (*Primitive) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{15} }

type isPrimitive_Value interface {
	isPrimitive_Value()
	MarshalTo([]byte) (int, error)
	Size() int
}

type Primitive_String_ struct {
	String_ string `protobuf:"bytes,1,opt,name=string,proto3,oneof"`
}
type Primitive_Int struct {
	Int int64 `protobuf:"varint,2,opt,name=int,proto3,oneof"`
}
type Primitive_Bool struct {
	Bool bool `protobuf:"varint,3,opt,name=bool,proto3,oneof"`
}
type Primitive_Float struct {
	Float float32 `protobuf:"fixed32,4,opt,name=float,proto3,oneof"`
}

func (*Primitive_String_) isPrimitive_Value() {}
func (*Primitive_Int) isPrimitive_Value()     {}
func (*Primitive_Bool) isPrimitive_Value()    {}
func (*Primitive_Float) isPrimitive_Value()   {}

func (m *Primitive) GetValue() isPrimitive_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *Primitive) GetString_() string {
	if x, ok := m.GetValue().(*Primitive_String_); ok {
		return x.String_
	}
	return ""
}

func (m *Primitive) GetInt() int64 {
	if x, ok := m.GetValue().(*Primitive_Int); ok {
		return x.Int
	}
	return 0
}

func (m *Primitive) GetBool() bool {
	if x, ok := m.GetValue().(*Primitive_Bool); ok {
		return x.Bool
	}
	return false
}

func (m *Primitive) GetFloat() float32 {
	if x, ok := m.GetValue().(*Primitive_Float); ok {
		return x.Float
	}
	return 0
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*Primitive) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _Primitive_OneofMarshaler, _Primitive_OneofUnmarshaler, _Primitive_OneofSizer, []interface{}{
		(*Primitive_String_)(nil),
		(*Primitive_Int)(nil),
		(*Primitive_Bool)(nil),
		(*Primitive_Float)(nil),
	}
}

func _Primitive_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		_ = b.EncodeVarint(1<<3 | proto.WireBytes)
		_ = b.EncodeStringBytes(x.String_)
	case *Primitive_Int:
		_ = b.EncodeVarint(2<<3 | proto.WireVarint)
		_ = b.EncodeVarint(uint64(x.Int))
	case *Primitive_Bool:
		t := uint64(0)
		if x.Bool {
			t = 1
		}
		_ = b.EncodeVarint(3<<3 | proto.WireVarint)
		_ = b.EncodeVarint(t)
	case *Primitive_Float:
		_ = b.EncodeVarint(4<<3 | proto.WireFixed32)
		_ = b.EncodeFixed32(uint64(math.Float32bits(x.Float)))
	case nil:
	default:
		return fmt.Errorf("Primitive.Value has unexpected type %T", x)
	}
	return nil
}

func _Primitive_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*Primitive)
	switch tag {
	case 1: // value.string
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeStringBytes()
		m.Value = &Primitive_String_{x}
		return true, err
	case 2: // value.int
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Int{int64(x)}
		return true, err
	case 3: // value.bool
		if wire != proto.WireVarint {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeVarint()
		m.Value = &Primitive_Bool{x != 0}
		return true, err
	case 4: // value.float
		if wire != proto.WireFixed32 {
			return true, proto.ErrInternalBadWireType
		}
		x, err := b.DecodeFixed32()
		m.Value = &Primitive_Float{math.Float32frombits(uint32(x))}
		return true, err
	default:
		return false, nil
	}
}

func _Primitive_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*Primitive)
	// value
	switch x := m.Value.(type) {
	case *Primitive_String_:
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(len(x.String_)))
		n += len(x.String_)
	case *Primitive_Int:
		n += proto.SizeVarint(2<<3 | proto.WireVarint)
		n += proto.SizeVarint(uint64(x.Int))
	case *Primitive_Bool:
		n += proto.SizeVarint(3<<3 | proto.WireVarint)
		n += 1
	case *Primitive_Float:
		n += proto.SizeVarint(4<<3 | proto.WireFixed32)
		n += 4
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Nothing struct {
}

func (m *Nothing) Reset()                    { *m = Nothing{} }
func (m *Nothing) String() string            { return proto.CompactTextString(m) }
func (*Nothing) ProtoMessage()               {}
func (*Nothing) Descriptor() ([]byte, []int) { return fileDescriptorTypes, []int{16} }

func init() {
	proto.RegisterType((*Age)(nil), "Age")
	proto.RegisterType((*Config)(nil), "Config")
	proto.RegisterType((*Players)(nil), "Players")
	proto.RegisterType((*PlayerList)(nil), "PlayerList")
	proto.RegisterType((*PlayerName)(nil), "PlayerName")
	proto.RegisterType((*Chunk)(nil), "Chunk")
	proto.RegisterType((*Chunk_Compound)(nil), "Chunk.Compound")
	proto.RegisterType((*Chunk_EntityAtPoint)(nil), "Chunk.EntityAtPoint")
	proto.RegisterType((*Chunk_ItemAtPoint)(nil), "Chunk.ItemAtPoint")
	proto.RegisterType((*Inventory)(nil), "Inventory")
	proto.RegisterType((*InventorySlot)(nil), "InventorySlot")
	proto.RegisterType((*Entity)(nil), "Entity")
	proto.RegisterType((*Entity_Player)(nil), "Entity.Player")
	proto.RegisterType((*Entity_NPC)(nil), "Entity.NPC")
	proto.RegisterType((*Item)(nil), "Item")
	proto.RegisterType((*Item_Components)(nil), "Item.Components")
	proto.RegisterType((*AbsolutePoint)(nil), "AbsolutePoint")
	proto.RegisterType((*Point)(nil), "Point")
	proto.RegisterType((*Actions)(nil), "Actions")
	proto.RegisterType((*Action)(nil), "Action")
	proto.RegisterType((*Action_MoveAction)(nil), "Action.MoveAction")
	proto.RegisterType((*Action_CraftAction)(nil), "Action.CraftAction")
	proto.RegisterType((*PrimitiveMap)(nil), "PrimitiveMap")
	proto.RegisterType((*Primitive)(nil), "Primitive")
	proto.RegisterType((*Nothing)(nil), "Nothing")
	proto.RegisterEnum("InventorySlot_ContainerType", InventorySlot_ContainerType_name, InventorySlot_ContainerType_value)
}
func (m *Age) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Age) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Ticks != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Ticks))
	}
	return i, nil
}

func (m *Config) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Config) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Options != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Options.Size()))
		n1, err := m.Options.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	return i, nil
}

func (m *Players) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Players) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, _ := range m.Players {
			dAtA[i] = 0xa
			i++
			v := m.Players[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n2, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n2
			}
		}
	}
	return i, nil
}

func (m *PlayerList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerList) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *PlayerName) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PlayerName) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	return i, nil
}

func (m *Chunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		dAtA4 := make([]byte, len(m.Voxels)*10)
		var j3 int
		for _, num := range m.Voxels {
			for num >= 1<<7 {
				dAtA4[j3] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j3++
			}
			dAtA4[j3] = uint8(num)
			j3++
		}
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j3))
		i += copy(dAtA[i:], dAtA4[:j3])
	}
	if len(m.Compound) > 0 {
		for k, _ := range m.Compound {
			dAtA[i] = 0x12
			i++
			v := m.Compound[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + sovTypes(uint64(k)) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintTypes(dAtA, i, uint64(k))
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n5, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n5
			}
		}
	}
	if len(m.Entities) > 0 {
		for _, msg := range m.Entities {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0x22
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Chunk_Compound) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_Compound) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Inventory != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n6, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if m.Properties != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n7, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if m.MultiblockChunk != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.MultiblockChunk.Size()))
		n8, err := m.MultiblockChunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *Chunk_EntityAtPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_EntityAtPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Point != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n9, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if m.Entity != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Entity.Size()))
		n10, err := m.Entity.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *Chunk_ItemAtPoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Chunk_ItemAtPoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Point != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Point.Size()))
		n11, err := m.Point.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.Item != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Item.Size()))
		n12, err := m.Item.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *Inventory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Inventory) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, msg := range m.Items {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *InventorySlot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InventorySlot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ContainerType != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ContainerLocation.Size()))
		n13, err := m.ContainerLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if len(m.Slots) > 0 {
		dAtA15 := make([]byte, len(m.Slots)*10)
		var j14 int
		for _, num := range m.Slots {
			for num >= 1<<7 {
				dAtA15[j14] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j14++
			}
			dAtA15[j14] = uint8(num)
			j14++
		}
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j14))
		i += copy(dAtA[i:], dAtA15[:j14])
	}
	return i, nil
}

func (m *Entity) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Control != nil {
		nn16, err := m.Control.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn16
	}
	if m.Type != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Type))
	}
	if m.Properties != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n17, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n17
	}
	if m.Inventory != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n18, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n18
	}
	return i, nil
}

func (m *Entity_Player_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Player != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Player.Size()))
		n19, err := m.Player.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n19
	}
	return i, nil
}
func (m *Entity_Npc) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Npc != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Npc.Size()))
		n20, err := m.Npc.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	return i, nil
}
func (m *Entity_Player) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_Player) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.LoggedIn {
		dAtA[i] = 0x8
		i++
		if m.LoggedIn {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Entity_NPC) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Entity_NPC) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Algorithm != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Algorithm))
	}
	return i, nil
}

func (m *Item) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Form != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Form))
	}
	if m.Substance != nil {
		nn21, err := m.Substance.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn21
	}
	if m.Properties != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Properties.Size()))
		n22, err := m.Properties.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.Inventory != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Inventory.Size()))
		n23, err := m.Inventory.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	return i, nil
}

func (m *Item_Material) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Material))
	return i, nil
}
func (m *Item_Components_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Components != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Components.Size()))
		n24, err := m.Components.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	return i, nil
}
func (m *Item_Components) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Item_Components) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, msg := range m.Components {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *AbsolutePoint) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AbsolutePoint) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Chunk != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Chunk.Size()))
		n25, err := m.Chunk.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Voxel != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Voxel.Size()))
		n26, err := m.Voxel.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	return i, nil
}

func (m *Point) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Point) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.X != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.X))
	}
	if m.Y != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Y))
	}
	if m.Z != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Z))
	}
	return i, nil
}

func (m *Actions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Actions) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, msg := range m.Actions {
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Action) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PlayerName) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(len(m.PlayerName)))
		i += copy(dAtA[i:], m.PlayerName)
	}
	if m.Action != nil {
		nn27, err := m.Action.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn27
	}
	return i, nil
}

func (m *Action_Move) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Move != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Move.Size()))
		n28, err := m.Move.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n28
	}
	return i, nil
}
func (m *Action_Craft) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	if m.Craft != nil {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Craft.Size()))
		n29, err := m.Craft.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n29
	}
	return i, nil
}
func (m *Action_MoveAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_MoveAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.WhereTo != nil {
		dAtA[i] = 0xa
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.WhereTo.Size()))
		n30, err := m.WhereTo.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n30
	}
	return i, nil
}

func (m *Action_CraftAction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Action_CraftAction) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Verb != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		dAtA[i] = 0x12
		i++
		i = encodeVarintTypes(dAtA, i, uint64(m.ObjectLocation.Size()))
		n31, err := m.ObjectLocation.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += n31
	}
	if len(m.Inputs) > 0 {
		for _, msg := range m.Inputs {
			dAtA[i] = 0x1a
			i++
			i = encodeVarintTypes(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.OutputForms) > 0 {
		dAtA33 := make([]byte, len(m.OutputForms)*10)
		var j32 int
		for _, num := range m.OutputForms {
			for num >= 1<<7 {
				dAtA33[j32] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j32++
			}
			dAtA33[j32] = uint8(num)
			j32++
		}
		dAtA[i] = 0x22
		i++
		i = encodeVarintTypes(dAtA, i, uint64(j32))
		i += copy(dAtA[i:], dAtA33[:j32])
	}
	return i, nil
}

func (m *PrimitiveMap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PrimitiveMap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, _ := range m.Map {
			dAtA[i] = 0xa
			i++
			v := m.Map[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovTypes(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovTypes(uint64(len(k))) + msgSize
			i = encodeVarintTypes(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintTypes(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintTypes(dAtA, i, uint64(v.Size()))
				n34, err := v.MarshalTo(dAtA[i:])
				if err != nil {
					return 0, err
				}
				i += n34
			}
		}
	}
	return i, nil
}

func (m *Primitive) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Primitive) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Value != nil {
		nn35, err := m.Value.MarshalTo(dAtA[i:])
		if err != nil {
			return 0, err
		}
		i += nn35
	}
	return i, nil
}

func (m *Primitive_String_) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0xa
	i++
	i = encodeVarintTypes(dAtA, i, uint64(len(m.String_)))
	i += copy(dAtA[i:], m.String_)
	return i, nil
}
func (m *Primitive_Int) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x10
	i++
	i = encodeVarintTypes(dAtA, i, uint64(m.Int))
	return i, nil
}
func (m *Primitive_Bool) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x18
	i++
	if m.Bool {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}
func (m *Primitive_Float) MarshalTo(dAtA []byte) (int, error) {
	i := 0
	dAtA[i] = 0x25
	i++
	binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Float))))
	i += 4
	return i, nil
}
func (m *Nothing) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Nothing) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func encodeVarintTypes(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Age) Size() (n int) {
	var l int
	_ = l
	if m.Ticks != 0 {
		n += 1 + sovTypes(uint64(m.Ticks))
	}
	return n
}

func (m *Config) Size() (n int) {
	var l int
	_ = l
	if m.Options != nil {
		l = m.Options.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Players) Size() (n int) {
	var l int
	_ = l
	if len(m.Players) > 0 {
		for k, v := range m.Players {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *PlayerList) Size() (n int) {
	var l int
	_ = l
	if len(m.Names) > 0 {
		for _, s := range m.Names {
			l = len(s)
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *PlayerName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk) Size() (n int) {
	var l int
	_ = l
	if len(m.Voxels) > 0 {
		l = 0
		for _, e := range m.Voxels {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	if len(m.Compound) > 0 {
		for k, v := range m.Compound {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + sovTypes(uint64(k)) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	if len(m.Entities) > 0 {
		for _, e := range m.Entities {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Chunk_Compound) Size() (n int) {
	var l int
	_ = l
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.MultiblockChunk != nil {
		l = m.MultiblockChunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk_EntityAtPoint) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Entity != nil {
		l = m.Entity.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Chunk_ItemAtPoint) Size() (n int) {
	var l int
	_ = l
	if m.Point != nil {
		l = m.Point.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Item != nil {
		l = m.Item.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Inventory) Size() (n int) {
	var l int
	_ = l
	if len(m.Items) > 0 {
		for _, e := range m.Items {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *InventorySlot) Size() (n int) {
	var l int
	_ = l
	if m.ContainerType != 0 {
		n += 1 + sovTypes(uint64(m.ContainerType))
	}
	if m.ContainerLocation != nil {
		l = m.ContainerLocation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Slots) > 0 {
		l = 0
		for _, e := range m.Slots {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *Entity) Size() (n int) {
	var l int
	_ = l
	if m.Control != nil {
		n += m.Control.Size()
	}
	if m.Type != 0 {
		n += 1 + sovTypes(uint64(m.Type))
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Entity_Player_) Size() (n int) {
	var l int
	_ = l
	if m.Player != nil {
		l = m.Player.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Entity_Npc) Size() (n int) {
	var l int
	_ = l
	if m.Npc != nil {
		l = m.Npc.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Entity_Player) Size() (n int) {
	var l int
	_ = l
	if m.LoggedIn {
		n += 2
	}
	return n
}

func (m *Entity_NPC) Size() (n int) {
	var l int
	_ = l
	if m.Algorithm != 0 {
		n += 1 + sovTypes(uint64(m.Algorithm))
	}
	return n
}

func (m *Item) Size() (n int) {
	var l int
	_ = l
	if m.Form != 0 {
		n += 1 + sovTypes(uint64(m.Form))
	}
	if m.Substance != nil {
		n += m.Substance.Size()
	}
	if m.Properties != nil {
		l = m.Properties.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Inventory != nil {
		l = m.Inventory.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Item_Material) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Material))
	return n
}
func (m *Item_Components_) Size() (n int) {
	var l int
	_ = l
	if m.Components != nil {
		l = m.Components.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Item_Components) Size() (n int) {
	var l int
	_ = l
	if len(m.Components) > 0 {
		for _, e := range m.Components {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *AbsolutePoint) Size() (n int) {
	var l int
	_ = l
	if m.Chunk != nil {
		l = m.Chunk.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Voxel != nil {
		l = m.Voxel.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Point) Size() (n int) {
	var l int
	_ = l
	if m.X != 0 {
		n += 1 + sovTypes(uint64(m.X))
	}
	if m.Y != 0 {
		n += 1 + sovTypes(uint64(m.Y))
	}
	if m.Z != 0 {
		n += 1 + sovTypes(uint64(m.Z))
	}
	return n
}

func (m *Actions) Size() (n int) {
	var l int
	_ = l
	if len(m.Actions) > 0 {
		for _, e := range m.Actions {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	return n
}

func (m *Action) Size() (n int) {
	var l int
	_ = l
	l = len(m.PlayerName)
	if l > 0 {
		n += 1 + l + sovTypes(uint64(l))
	}
	if m.Action != nil {
		n += m.Action.Size()
	}
	return n
}

func (m *Action_Move) Size() (n int) {
	var l int
	_ = l
	if m.Move != nil {
		l = m.Move.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_Craft) Size() (n int) {
	var l int
	_ = l
	if m.Craft != nil {
		l = m.Craft.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}
func (m *Action_MoveAction) Size() (n int) {
	var l int
	_ = l
	if m.WhereTo != nil {
		l = m.WhereTo.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	return n
}

func (m *Action_CraftAction) Size() (n int) {
	var l int
	_ = l
	if m.Verb != 0 {
		n += 1 + sovTypes(uint64(m.Verb))
	}
	if m.ObjectLocation != nil {
		l = m.ObjectLocation.Size()
		n += 1 + l + sovTypes(uint64(l))
	}
	if len(m.Inputs) > 0 {
		for _, e := range m.Inputs {
			l = e.Size()
			n += 1 + l + sovTypes(uint64(l))
		}
	}
	if len(m.OutputForms) > 0 {
		l = 0
		for _, e := range m.OutputForms {
			l += sovTypes(uint64(e))
		}
		n += 1 + sovTypes(uint64(l)) + l
	}
	return n
}

func (m *PrimitiveMap) Size() (n int) {
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovTypes(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovTypes(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovTypes(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *Primitive) Size() (n int) {
	var l int
	_ = l
	if m.Value != nil {
		n += m.Value.Size()
	}
	return n
}

func (m *Primitive_String_) Size() (n int) {
	var l int
	_ = l
	l = len(m.String_)
	n += 1 + l + sovTypes(uint64(l))
	return n
}
func (m *Primitive_Int) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovTypes(uint64(m.Int))
	return n
}
func (m *Primitive_Bool) Size() (n int) {
	var l int
	_ = l
	n += 2
	return n
}
func (m *Primitive_Float) Size() (n int) {
	var l int
	_ = l
	n += 5
	return n
}
func (m *Nothing) Size() (n int) {
	var l int
	_ = l
	return n
}

func sovTypes(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozTypes(x uint64) (n int) {
	return sovTypes(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Age) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Age: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Age: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticks", wireType)
			}
			m.Ticks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ticks |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Config) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Config: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Config: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Options", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Options == nil {
				m.Options = &PrimitiveMap{}
			}
			if err := m.Options.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Players) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Players: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Players: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Players", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Players == nil {
				m.Players = make(map[string]*AbsolutePoint)
			}
			var mapkey string
			var mapvalue *AbsolutePoint
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &AbsolutePoint{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Players[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Names", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Names = append(m.Names, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PlayerName) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PlayerName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PlayerName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Chunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Chunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Voxels = append(m.Voxels, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Voxels = append(m.Voxels, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxels", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compound", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compound == nil {
				m.Compound = make(map[uint32]*Chunk_Compound)
			}
			var mapkey uint32
			var mapvalue *Chunk_Compound
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Chunk_Compound{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Compound[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entities", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entities = append(m.Entities, &Chunk_EntityAtPoint{})
			if err := m.Entities[len(m.Entities)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Chunk_ItemAtPoint{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_Compound) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Compound: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Compound: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MultiblockChunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.MultiblockChunk == nil {
				m.MultiblockChunk = &Point{}
			}
			if err := m.MultiblockChunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_EntityAtPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntityAtPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntityAtPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entity", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Entity == nil {
				m.Entity = &Entity{}
			}
			if err := m.Entity.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Chunk_ItemAtPoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ItemAtPoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ItemAtPoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Point", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Point == nil {
				m.Point = &Point{}
			}
			if err := m.Point.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Item", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Item == nil {
				m.Item = &Item{}
			}
			if err := m.Item.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Inventory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Inventory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Inventory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Items", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Items = append(m.Items, &Item{})
			if err := m.Items[len(m.Items)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InventorySlot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InventorySlot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InventorySlot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerType", wireType)
			}
			m.ContainerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ContainerType |= (InventorySlot_ContainerType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContainerLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContainerLocation == nil {
				m.ContainerLocation = &AbsolutePoint{}
			}
			if err := m.ContainerLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Slots = append(m.Slots, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Slots = append(m.Slots, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Slots", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entity: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entity: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Player", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_Player{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &Entity_Player_{v}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Npc", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Entity_NPC{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Control = &Entity_Npc{v}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_Player) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Player: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Player: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LoggedIn", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.LoggedIn = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entity_NPC) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NPC: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NPC: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algorithm", wireType)
			}
			m.Algorithm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Algorithm |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Item: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Item: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Form", wireType)
			}
			m.Form = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Form |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Material", wireType)
			}
			var v uint32
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Substance = &Item_Material{v}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Item_Components{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Substance = &Item_Components_{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Properties", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Properties == nil {
				m.Properties = &PrimitiveMap{}
			}
			if err := m.Properties.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inventory", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Inventory == nil {
				m.Inventory = &Inventory{}
			}
			if err := m.Inventory.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Item_Components) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Components: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Components: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Components", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Components = append(m.Components, &Item{})
			if err := m.Components[len(m.Components)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AbsolutePoint) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AbsolutePoint: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AbsolutePoint: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Chunk", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Chunk == nil {
				m.Chunk = &Point{}
			}
			if err := m.Chunk.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Voxel", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Voxel == nil {
				m.Voxel = &Point{}
			}
			if err := m.Voxel.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Point) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field X", wireType)
			}
			m.X = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.X |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Y", wireType)
			}
			m.Y = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Y |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Z", wireType)
			}
			m.Z = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Z |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Actions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Actions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Actions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Actions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Actions = append(m.Actions, &Action{})
			if err := m.Actions[len(m.Actions)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Action: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Action: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlayerName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PlayerName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Move", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_MoveAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Move{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Craft", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &Action_CraftAction{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Action = &Action_Craft{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_MoveAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoveAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoveAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WhereTo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.WhereTo == nil {
				m.WhereTo = &AbsolutePoint{}
			}
			if err := m.WhereTo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Action_CraftAction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CraftAction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CraftAction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verb", wireType)
			}
			m.Verb = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Verb |= (uint32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectLocation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ObjectLocation == nil {
				m.ObjectLocation = &AbsolutePoint{}
			}
			if err := m.ObjectLocation.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Inputs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Inputs = append(m.Inputs, &InventorySlot{})
			if err := m.Inputs[len(m.Inputs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v uint32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= (uint32(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.OutputForms = append(m.OutputForms, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= (int(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthTypes
				}
				postIndex := iNdEx + packedLen
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				for iNdEx < postIndex {
					var v uint32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= (uint32(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.OutputForms = append(m.OutputForms, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputForms", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PrimitiveMap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PrimitiveMap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PrimitiveMap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*Primitive)
			}
			var mapkey string
			var mapvalue *Primitive
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthTypes
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowTypes
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= (int(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					postmsgIndex := iNdEx + mapmsglen
					if mapmsglen < 0 {
						return ErrInvalidLengthTypes
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Primitive{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipTypes(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthTypes
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Primitive) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Primitive: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Primitive: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field String_", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTypes
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = &Primitive_String_{string(dAtA[iNdEx:postIndex])}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Int", wireType)
			}
			var v int64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Value = &Primitive_Int{v}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bool", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			b := bool(v != 0)
			m.Value = &Primitive_Bool{b}
		case 4:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Float", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Value = &Primitive_Float{float32(math.Float32frombits(v))}
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Nothing) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Nothing: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Nothing: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipTypes(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthTypes
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTypes(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTypes
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTypes
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthTypes
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowTypes
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipTypes(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthTypes = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTypes   = fmt.Errorf("proto: integer overflow")
)

func init() { proto.RegisterFile("types/types.proto", fileDescriptorTypes) }

var fileDescriptorTypes = []byte{
	// 1111 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x56, 0xcf, 0x6f, 0xe3, 0xc4,
	0x17, 0x8f, 0xe3, 0xc4, 0x49, 0x5e, 0xea, 0x6e, 0xf6, 0x7d, 0xfb, 0xad, 0x82, 0xb7, 0xea, 0x16,
	0xb3, 0x0b, 0x91, 0x00, 0x6f, 0xb7, 0x2b, 0xad, 0x10, 0xe2, 0xd2, 0x44, 0x5d, 0xb5, 0xd0, 0x86,
	0x6a, 0xa8, 0x10, 0x1c, 0x1d, 0xef, 0x34, 0x35, 0xb5, 0x3d, 0x96, 0x3d, 0x09, 0xcd, 0x8a, 0x33,
	0xfc, 0x05, 0x20, 0xee, 0x1c, 0xf9, 0x47, 0x38, 0x72, 0xe5, 0x86, 0xca, 0x81, 0x7f, 0x03, 0xcd,
	0x0f, 0xbb, 0x76, 0x59, 0xe8, 0x89, 0x4b, 0x32, 0xef, 0xf3, 0x3e, 0xf3, 0xe6, 0xcd, 0xfb, 0x35,
	0x86, 0xfb, 0x7c, 0x95, 0xd2, 0xfc, 0x89, 0xfc, 0xf5, 0xd2, 0x8c, 0x71, 0xe6, 0x3e, 0x00, 0x73,
	0x7f, 0x4e, 0x71, 0x03, 0xda, 0x3c, 0x0c, 0x2e, 0xf3, 0xa1, 0xb1, 0x63, 0x8c, 0x5a, 0x44, 0x09,
	0xee, 0x53, 0xb0, 0x26, 0x2c, 0x39, 0x0f, 0xe7, 0xf8, 0x0e, 0x74, 0x58, 0xca, 0x43, 0x96, 0x28,
	0x46, 0x7f, 0xcf, 0xf6, 0x4e, 0xb3, 0x30, 0x0e, 0x79, 0xb8, 0xa4, 0x27, 0x7e, 0x4a, 0x0a, 0xad,
	0xfb, 0xad, 0x01, 0x9d, 0xd3, 0xc8, 0x5f, 0xd1, 0x2c, 0xc7, 0x27, 0xd0, 0x49, 0xd5, 0x72, 0x68,
	0xec, 0x98, 0xa3, 0xfe, 0xde, 0xff, 0x3d, 0xad, 0x2a, 0xfe, 0x0f, 0x12, 0x9e, 0xad, 0x48, 0xc1,
	0x72, 0x3e, 0x86, 0xb5, 0xaa, 0x02, 0x07, 0x60, 0x5e, 0xd2, 0x95, 0x3c, 0xb1, 0x47, 0xc4, 0x12,
	0x1f, 0x41, 0x7b, 0xe9, 0x47, 0x0b, 0x3a, 0x6c, 0x4a, 0x2f, 0xd6, 0xbd, 0xfd, 0x59, 0xce, 0xa2,
	0x05, 0xa7, 0xa7, 0x2c, 0x4c, 0x38, 0x51, 0xca, 0x0f, 0x9b, 0x1f, 0x18, 0xae, 0x0b, 0xa0, 0x6c,
	0x1d, 0x87, 0x39, 0x17, 0xf7, 0x4b, 0xfc, 0x98, 0x2a, 0x47, 0x7a, 0x44, 0x09, 0xee, 0x4e, 0xc1,
	0x99, 0xfa, 0x31, 0x45, 0x84, 0x96, 0x80, 0xf5, 0x71, 0x72, 0xed, 0xfe, 0xdc, 0x82, 0xf6, 0xe4,
	0x62, 0x91, 0x5c, 0xe2, 0x26, 0x58, 0x4b, 0x76, 0x45, 0x23, 0x65, 0xa2, 0x45, 0xb4, 0x84, 0xbb,
	0xd0, 0x0d, 0x58, 0x9c, 0xb2, 0x45, 0xf2, 0x72, 0xd8, 0x94, 0xb7, 0xdc, 0xf0, 0xe4, 0x0e, 0x6f,
	0xa2, 0x61, 0x75, 0xc9, 0x92, 0x25, 0x76, 0xd0, 0x84, 0x87, 0x3c, 0xa4, 0xf9, 0xd0, 0xac, 0xed,
	0x38, 0x10, 0xf0, 0x6a, 0x9f, 0xab, 0xcb, 0x94, 0x2c, 0x1c, 0x41, 0x3b, 0xe4, 0x34, 0xce, 0x87,
	0x2d, 0x49, 0x47, 0x4d, 0x3f, 0xe2, 0x34, 0x2e, 0xc8, 0x8a, 0xe0, 0x7c, 0x6f, 0x40, 0xb7, 0x38,
	0x17, 0x47, 0xd0, 0x0b, 0x93, 0x25, 0x4d, 0x38, 0xcb, 0x56, 0x3a, 0x6d, 0xe0, 0x1d, 0x15, 0x08,
	0xb9, 0x51, 0xe2, 0xfb, 0x00, 0x69, 0xc6, 0x52, 0x9a, 0x49, 0xa7, 0x9a, 0xaf, 0xcb, 0x70, 0x85,
	0x80, 0xbb, 0x70, 0x2f, 0x5e, 0x44, 0x3c, 0x9c, 0x45, 0x2c, 0xb8, 0x94, 0xbe, 0x0c, 0x4d, 0xb9,
	0xc7, 0xf2, 0x94, 0x37, 0xb7, 0xd5, 0xce, 0x31, 0xd8, 0xb5, 0x70, 0x54, 0x53, 0x6b, 0xab, 0xd4,
	0x3e, 0xae, 0xa7, 0xf6, 0xde, 0xad, 0x28, 0x56, 0x72, 0xeb, 0x4c, 0xc1, 0xae, 0x85, 0x0a, 0xb7,
	0xa0, 0x9d, 0x8a, 0x85, 0xbe, 0x65, 0xe1, 0x86, 0x02, 0xf1, 0x21, 0x58, 0x32, 0x94, 0x2b, 0x6d,
	0xba, 0xa3, 0x03, 0x4d, 0x34, 0xec, 0xbc, 0x80, 0x7e, 0x25, 0x96, 0x77, 0x58, 0x7b, 0x03, 0x5a,
	0x22, 0xd6, 0xda, 0x56, 0x5b, 0x66, 0x81, 0x48, 0xc8, 0x1d, 0x41, 0xaf, 0x0c, 0x2f, 0x3e, 0x28,
	0x92, 0xa6, 0x6a, 0x5f, 0x13, 0x15, 0xe6, 0xfe, 0x66, 0x80, 0x5d, 0x52, 0x3f, 0x8b, 0x18, 0xc7,
	0x31, 0xd8, 0x01, 0x4b, 0xb8, 0x1f, 0x26, 0x34, 0x3b, 0x5b, 0xa5, 0xaa, 0x0c, 0xd7, 0xf7, 0xb6,
	0xbc, 0x1a, 0xcd, 0x9b, 0x54, 0x39, 0xa4, 0xbe, 0x05, 0x3f, 0x82, 0xfb, 0x25, 0x70, 0xcc, 0x02,
	0x5f, 0xb4, 0xe4, 0x3f, 0x74, 0xca, 0xdf, 0x89, 0xa2, 0x47, 0xf2, 0x88, 0x71, 0x55, 0x94, 0x36,
	0x51, 0x82, 0xbb, 0x2b, 0x32, 0x57, 0x3d, 0xa4, 0x07, 0xed, 0xcf, 0x3f, 0xfd, 0xe2, 0xe0, 0x78,
	0xd0, 0x40, 0x00, 0xeb, 0x60, 0x7a, 0x76, 0x74, 0xf6, 0xe5, 0xc0, 0xc0, 0x2e, 0xb4, 0x8e, 0xce,
	0x0e, 0x4e, 0x06, 0x4d, 0xf7, 0x87, 0x26, 0x58, 0x2a, 0xc0, 0x38, 0x02, 0x4b, 0xf5, 0xb6, 0x0e,
	0xe5, 0xba, 0x8e, 0xbc, 0xee, 0xff, 0xc3, 0x06, 0xd1, 0x7a, 0x7c, 0x08, 0x66, 0x92, 0x06, 0xda,
	0xd9, 0x7e, 0x41, 0x9b, 0x9e, 0x4e, 0x0e, 0x1b, 0x44, 0x68, 0x44, 0x77, 0x8a, 0xb9, 0x25, 0x0b,
	0xcd, 0x26, 0x72, 0x7d, 0xab, 0x6c, 0x5b, 0x77, 0x95, 0x6d, 0xad, 0x1f, 0xda, 0xff, 0xd2, 0x0f,
	0xce, 0x23, 0xb0, 0x94, 0x87, 0xe8, 0x40, 0x37, 0x62, 0xf3, 0x39, 0x7d, 0x79, 0x94, 0xc8, 0x3b,
	0x74, 0x49, 0x29, 0x3b, 0x6f, 0x81, 0x39, 0x3d, 0x9d, 0xe0, 0x16, 0xf4, 0xf6, 0xa3, 0x39, 0xcb,
	0x42, 0x7e, 0x11, 0xeb, 0x82, 0xbe, 0x01, 0xc6, 0x3d, 0xe8, 0x88, 0x50, 0x67, 0x2c, 0x72, 0xbf,
	0x6b, 0x42, 0x4b, 0x14, 0x81, 0xb8, 0xcb, 0x39, 0xcb, 0x0a, 0xb2, 0x5c, 0xe3, 0x16, 0x74, 0x63,
	0x9f, 0xd3, 0x2c, 0xf4, 0x23, 0x19, 0x05, 0xfb, 0xb0, 0x41, 0x4a, 0x04, 0xf7, 0x00, 0xe4, 0xfc,
	0x48, 0x68, 0x22, 0x13, 0x24, 0x7c, 0x1f, 0xc8, 0x8a, 0x52, 0x0d, 0x22, 0xf1, 0xc3, 0x06, 0xa9,
	0xb0, 0xfe, 0xbb, 0xe8, 0x3c, 0x03, 0xb8, 0x39, 0x14, 0x1f, 0xd7, 0x5c, 0xab, 0x15, 0x7b, 0x45,
	0x31, 0xee, 0x43, 0x2f, 0x5f, 0xcc, 0x72, 0xee, 0x27, 0x01, 0x75, 0x3f, 0x01, 0xbb, 0x56, 0x8e,
	0xa2, 0xe5, 0x02, 0x39, 0x47, 0x6e, 0xb5, 0x9c, 0x04, 0x85, 0x56, 0x4e, 0x5b, 0x5d, 0x1e, 0xa5,
	0x56, 0x82, 0xee, 0x53, 0x68, 0x2b, 0x23, 0x6b, 0x60, 0x5c, 0x49, 0x03, 0x26, 0x31, 0xae, 0x84,
	0xa4, 0x1a, 0xde, 0x24, 0xc6, 0x4a, 0x48, 0xaf, 0x64, 0xdc, 0x4c, 0x62, 0xbc, 0x72, 0xdf, 0x83,
	0xce, 0x7e, 0x20, 0x1f, 0x2c, 0x7c, 0x13, 0x3a, 0x7e, 0x50, 0xbc, 0x6c, 0xa6, 0x9c, 0x0e, 0x4a,
	0x45, 0x0a, 0xdc, 0xfd, 0xb3, 0x09, 0x96, 0xc2, 0x70, 0x1b, 0x20, 0x2d, 0x5f, 0x0c, 0xfd, 0x52,
	0x54, 0x10, 0x1c, 0x41, 0x2b, 0x66, 0xcb, 0x62, 0x86, 0xa1, 0x36, 0xe5, 0x9d, 0xb0, 0x25, 0x55,
	0xcb, 0xc3, 0x06, 0x91, 0x0c, 0x7c, 0x17, 0xda, 0x41, 0xe6, 0x9f, 0x73, 0x9d, 0xcc, 0xff, 0x15,
	0xd4, 0x89, 0x00, 0x4b, 0xae, 0xe2, 0x38, 0xcf, 0x01, 0x6e, 0x4c, 0xe0, 0x08, 0x3a, 0x5f, 0x5f,
	0xd0, 0x8c, 0x9e, 0xb1, 0xb2, 0xad, 0xea, 0xcd, 0x5d, 0xa8, 0x9d, 0x9f, 0x0c, 0xe8, 0x57, 0x0c,
	0x8a, 0xc2, 0x5b, 0xd2, 0x6c, 0x56, 0x14, 0x9e, 0x58, 0xe3, 0x73, 0x58, 0x67, 0xb3, 0xaf, 0x68,
	0xc0, 0xef, 0x98, 0x18, 0xb7, 0x58, 0xf8, 0x36, 0x58, 0x61, 0x92, 0x2e, 0x78, 0xf1, 0x88, 0xad,
	0xd7, 0x27, 0x15, 0xd1, 0x5a, 0xdc, 0x81, 0x3e, 0x5b, 0xf0, 0x74, 0xc1, 0x5f, 0xb0, 0x4c, 0x3f,
	0x61, 0x36, 0xa9, 0x42, 0xe3, 0x2e, 0x58, 0x2a, 0xd4, 0xee, 0x37, 0xb0, 0x56, 0xad, 0x4f, 0x1c,
	0x81, 0x19, 0xfb, 0xa9, 0x4e, 0xcc, 0x66, 0xad, 0x76, 0xbd, 0x13, 0x3f, 0x55, 0x2f, 0xab, 0xa0,
	0x38, 0x63, 0xe8, 0x16, 0xc0, 0x6b, 0x3e, 0x1b, 0x76, 0xea, 0x6f, 0x0b, 0xdc, 0x58, 0xaa, 0x7e,
	0x32, 0xa4, 0xd0, 0x2b, 0x71, 0x1c, 0x82, 0x95, 0xf3, 0x2c, 0x4c, 0xe6, 0xca, 0x8e, 0x18, 0x55,
	0x4a, 0x46, 0x04, 0x53, 0x3c, 0x0e, 0xb2, 0xb4, 0xc4, 0x74, 0x12, 0xa5, 0xb7, 0x01, 0xad, 0x19,
	0x63, 0x91, 0x4c, 0x66, 0x57, 0xe4, 0x58, 0x48, 0xb8, 0x09, 0xed, 0xf3, 0x88, 0xf9, 0x5c, 0x36,
	0x5f, 0x53, 0xa4, 0x53, 0x8a, 0xe3, 0x8e, 0x76, 0xc7, 0xed, 0x41, 0x67, 0xca, 0xf8, 0x45, 0x98,
	0xcc, 0xc7, 0x83, 0x5f, 0xae, 0xb7, 0x8d, 0x5f, 0xaf, 0xb7, 0x8d, 0xdf, 0xaf, 0xb7, 0x8d, 0x1f,
	0xff, 0xd8, 0x6e, 0xcc, 0x2c, 0xf9, 0x85, 0xf6, 0xec, 0xaf, 0x00, 0x00, 0x00, 0xff, 0xff, 0xa2,
	0x12, 0x27, 0x72, 0xb6, 0x09, 0x00, 0x00,
}
